<!DOCTYPE html>
<html lang="en" data-theme="system">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HtmlGraph Dashboard</title>
    <!-- Vis.js for graph visualization -->
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <link href="https://unpkg.com/vis-network/styles/vis-network.min.css" rel="stylesheet" type="text/css" />
    <!-- Typography: JetBrains Mono + Outfit -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* ================================================================
           COLOR SYSTEM & THEME
           ================================================================ */
        :root {
            /* Light Theme (default) */
            --bg-primary: #F8F7F4;
            --bg-secondary: #FFFFFF;
            --bg-tertiary: #EEEDE8;
            --text-primary: #0A0A0A;
            --text-secondary: #4A4A4A;
            --text-muted: #8A8A8A;
            --border: #E0DED8;
            --border-strong: #0A0A0A;

            /* Accent Colors */
            --accent: #CDFF00;
            --accent-dim: #B8E600;
            --accent-text: #0A0A0A;

            /* Status Colors - Vivid */
            --status-done: #00C853;
            --status-active: #2979FF;
            --status-blocked: #FF1744;
            --status-todo: #78909C;

            /* Priority Colors */
            --priority-critical: #FF1744;
            --priority-high: #FF9100;
            --priority-medium: #2979FF;
            --priority-low: #78909C;

            /* Shadows - Sharp, not soft */
            --shadow-sm: 2px 2px 0 var(--border-strong);
            --shadow-md: 4px 4px 0 var(--border-strong);
            --shadow-lg: 6px 6px 0 var(--border-strong);
            --shadow-hover: 8px 8px 0 var(--border-strong);

            /* Timing */
            --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
            --ease-spring: cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        /* Dark Theme - Softer contrast for eye comfort */
        [data-theme="dark"] {
            --bg-primary: #151518;
            --bg-secondary: #1C1C20;
            --bg-tertiary: #252528;
            --text-primary: #E0DED8;
            --text-secondary: #A0A0A0;
            --text-muted: #707070;
            --border: #333338;
            --border-strong: #606068;

            --shadow-sm: 2px 2px 0 rgba(0, 0, 0, 0.4);
            --shadow-md: 4px 4px 0 rgba(0, 0, 0, 0.4);
            --shadow-lg: 6px 6px 0 rgba(0, 0, 0, 0.4);
            --shadow-hover: 8px 8px 0 rgba(0, 0, 0, 0.4);
        }

        /* System preference */
        @media (prefers-color-scheme: dark) {
            [data-theme="system"] {
                --bg-primary: #151518;
                --bg-secondary: #1C1C20;
                --bg-tertiary: #252528;
                --text-primary: #E0DED8;
                --text-secondary: #A0A0A0;
                --text-muted: #707070;
                --border: #333338;
                --border-strong: #606068;

                --shadow-sm: 2px 2px 0 rgba(0, 0, 0, 0.4);
                --shadow-md: 4px 4px 0 rgba(0, 0, 0, 0.4);
                --shadow-lg: 6px 6px 0 rgba(0, 0, 0, 0.4);
                --shadow-hover: 8px 8px 0 rgba(0, 0, 0, 0.4);
            }
        }

        /* ================================================================
           BASE STYLES
           ================================================================ */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Outfit', system-ui, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
            height: 100vh;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Subtle grain texture overlay */
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            opacity: 0.03;
            pointer-events: none;
            z-index: 9999;
        }

        .container {
            max-width: 1440px;
            margin: 0 auto;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            width: 100%;
            overflow: hidden;
        }

        /* ================================================================
           HEADER
           ================================================================ */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 3rem;
            padding-bottom: 2rem;
            border-bottom: 2px solid var(--border-strong);
        }

        .brand {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .brand-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 2rem;
            font-weight: 700;
            letter-spacing: -0.02em;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .brand-title::before {
            content: '<>';
            color: var(--accent);
            font-weight: 400;
        }

        .brand-tagline {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-muted);
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        /* Theme Toggle */
        .theme-toggle {
            width: 44px;
            height: 44px;
            border: 2px solid var(--border-strong);
            background: var(--bg-secondary);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            transition: all 0.2s var(--ease-out-expo);
            box-shadow: var(--shadow-sm);
        }

        .theme-toggle:hover {
            transform: translate(-2px, -2px);
            box-shadow: var(--shadow-md);
        }

        .theme-toggle:active {
            transform: translate(0, 0);
            box-shadow: none;
        }

        /* ================================================================
           VIEW TOGGLE
           ================================================================ */
        .view-toggle {
            display: flex;
            gap: 0;
            margin-bottom: 1rem;
            border: 2px solid var(--border-strong);
            width: fit-content;
            flex-shrink: 0;
        }

        .view-btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            padding: 0.875rem 1.5rem;
            border: none;
            background: var(--bg-secondary);
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.2s var(--ease-out-expo);
            position: relative;
        }

        .view-btn:not(:last-child) {
            border-right: 2px solid var(--border-strong);
        }

        .view-btn:hover {
            color: var(--text-primary);
            background: var(--bg-tertiary);
        }

        .view-btn.active {
            background: var(--accent);
            color: var(--accent-text);
        }

        /* ================================================================
           KANBAN BOARD
           ================================================================ */
        .kanban {
            display: none;
            grid-template-columns: repeat(4, 1fr);
            gap: 1.5rem;
        }

        .kanban.active {
            display: grid;
            width: 100%;
            height: 100%;
            flex: 1;
            min-height: 0;
            overflow: auto;
            grid-auto-rows: minmax(0, 1fr);
            grid-auto-flow: dense;
        }

        /* Dynamic grid: expanded columns grow, collapsed stay fixed */
        .kanban.has-collapsed {
            grid-template-columns: var(--kanban-grid, repeat(4, 1fr));
        }

        @media (max-width: 1200px) {
            .kanban:not(.has-collapsed) { grid-template-columns: repeat(2, 1fr); }
        }

        @media (max-width: 768px) {
            .kanban { grid-template-columns: 1fr !important; }
            .column.collapsed {
                max-width: none;
                min-width: 0;
                flex-direction: row;
            }
            .column.collapsed .column-header {
                writing-mode: horizontal-tb;
                flex-direction: row;
                height: auto;
                border-bottom: 2px solid var(--border-strong);
            }
            .column.collapsed .column-cards {
                display: flex;
            }
        }

        .column {
            background: var(--bg-secondary);
            border: 2px solid var(--border-strong);
            box-shadow: var(--shadow-md);
            display: flex;
            flex-direction: column;
            max-height: 70vh;
            transition: all 0.3s var(--ease-out-expo);
            min-width: 0;
        }

        .column.collapsed {
            min-width: 52px;
            max-width: 52px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            align-self: stretch;
        }

        /* When all columns are collapsed, center them */
        .kanban.all-collapsed {
            justify-content: center;
        }

        /* Status-colored accent strip on collapsed columns */
        .column.collapsed::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: var(--status-todo);
            transition: width 0.3s var(--ease-out-expo);
        }
        .column.collapsed.in-progress::before { background: var(--status-active); }
        .column.collapsed.blocked::before { background: var(--status-blocked); }
        .column.collapsed.done::before { background: var(--status-done); }

        /* Breathing glow on hover to hint expandability */
        .column.collapsed:hover::before {
            width: 6px;
            box-shadow: 0 0 12px currentColor;
        }
        .column.collapsed:hover {
            background: var(--bg-tertiary);
        }

        .column.collapsed .column-header {
            flex-direction: column;
            padding: 0.75rem 0.5rem;
            gap: 0.5rem;
            align-items: center;
            justify-content: flex-start;
            height: auto;
            border-bottom: none;
            background: transparent;
        }

        .column.collapsed .column-header-left {
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            order: 1;
        }

        .column.collapsed .column-count {
            writing-mode: horizontal-tb;
            font-size: 1.25rem;
            font-weight: 800;
            background: transparent;
            border: none;
            padding: 0;
            order: -1;
        }

        .column.collapsed .column-title {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            white-space: nowrap;
            font-size: 0.625rem;
            letter-spacing: 0.2em;
        }

        .column.collapsed .column-title::before {
            display: none;
        }

        .column.collapsed .column-cards {
            display: none;
        }

        /* Collapse button at top of collapsed column */
        .column.collapsed .collapse-btn {
            writing-mode: horizontal-tb;
            transform: rotate(0deg);
            border: none;
            background: transparent;
            opacity: 0.5;
            order: -2;
            flex-shrink: 0;
        }

        .column.collapsed:hover .collapse-btn {
            opacity: 1;
        }

        .column-header {
            padding: 1rem 1.25rem;
            border-bottom: 2px solid var(--border-strong);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-tertiary);
        }

        .column-header-left {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        /* Refined collapse button with chevron */
        .collapse-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s var(--ease-out-expo);
            position: relative;
        }

        .collapse-btn::before,
        .collapse-btn::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 2px;
            background: currentColor;
            transition: transform 0.2s var(--ease-out-expo);
        }

        .collapse-btn::before {
            transform: rotate(-45deg) translateY(-2px);
        }

        .collapse-btn::after {
            transform: rotate(45deg) translateY(2px);
        }

        .collapse-btn:hover {
            color: var(--text-primary);
        }

        .collapse-btn:hover::before {
            transform: rotate(-45deg) translateY(-2px) translateX(-2px);
        }

        .collapse-btn:hover::after {
            transform: rotate(45deg) translateY(2px) translateX(-2px);
        }

        /* Expanded state chevron points left */
        .column:not(.collapsed) .collapse-btn::before,
        .column:not(.collapsed) .collapse-btn::after {
            transform-origin: center;
        }

        /* Collapsed state chevron points right */
        .column.collapsed .collapse-btn::before {
            transform: rotate(45deg) translateY(-2px);
        }

        .column.collapsed .collapse-btn::after {
            transform: rotate(-45deg) translateY(2px);
        }

        .column.collapsed .collapse-btn:hover::before {
            transform: rotate(45deg) translateY(-2px) translateX(2px);
        }

        .column.collapsed .collapse-btn:hover::after {
            transform: rotate(-45deg) translateY(2px) translateX(2px);
        }

        .column-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .column-title::before {
            content: '';
            width: 8px;
            height: 8px;
            background: var(--status-todo);
            flex-shrink: 0;
        }

        .column.in-progress .column-title::before { background: var(--status-active); }
        .column.blocked .column-title::before { background: var(--status-blocked); }
        .column.done .column-title::before { background: var(--status-done); }

        .column-count {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 700;
            background: var(--bg-primary);
            padding: 0.25rem 0.5rem;
            border: 1px solid var(--border);
        }

        .column-cards {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        /* ================================================================
           TRACK-GROUPED KANBAN
           ================================================================ */
        .track-sections-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            width: 100%;
            max-width: 100%;
            grid-column: 1 / -1;
        }

        .track-section {
            background: var(--bg-secondary);
            border: 2px solid var(--border-strong);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: var(--shadow-md);
            transition: all 0.3s var(--ease-out-expo);
        }

        .track-header {
            padding: 1rem 1.5rem;
            background: var(--bg-tertiary);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            transition: background 0.2s;
            border-bottom: 2px solid var(--border);
        }

        .track-header:hover {
            background: var(--border);
        }

        .track-title-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .track-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .track-icon {
            font-size: 1.5rem;
        }

        .track-title h3 {
            margin: 0;
            color: var(--accent);
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.125rem;
            font-weight: 600;
        }

        .track-meta {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .track-link-btn {
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            font-weight: 500;
        }

        .track-link-btn:hover:not(:disabled):not(.disabled) {
            background: var(--accent);
            color: var(--accent-text);
            border-color: var(--accent);
            transform: translateY(-1px);
        }

        .track-link-btn:disabled,
        .track-link-btn.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .track-link-full {
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 1.25rem;
            transition: color 0.2s;
        }

        .track-link-full:hover {
            color: var(--accent);
        }

        .track-progress-bar {
            position: relative;
            width: 100%;
            height: 24px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .progress-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: linear-gradient(90deg, var(--accent) 0%, var(--accent-bright) 100%);
            transition: width 0.4s var(--ease-out-expo);
            border-radius: 4px;
            opacity: 0.8;
        }

        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--bg-primary);
            font-weight: 700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            mix-blend-mode: difference;
        }

        .expand-icon {
            transition: transform 0.3s var(--ease-out-expo);
            color: var(--text-muted);
            font-size: 1rem;
        }

        .track-section.expanded .expand-icon,
        .untracked-section.expanded .expand-icon {
            transform: rotate(180deg);
        }

        .track-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s var(--ease-out-expo);
        }

        .track-content.collapsed {
            max-height: 0;
        }

        .track-section.expanded .track-content {
            max-height: 2000px;
            padding: 1rem;
        }

        /* Track Kanban Grid */
        .track-kanban {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
        }

        @media (max-width: 1200px) {
            .track-kanban {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .track-kanban {
                grid-template-columns: 1fr;
            }
        }

        .track-column {
            background: var(--bg-primary);
            border: 2px solid var(--border);
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            max-height: 60vh;
        }

        .track-column-header {
            padding: 0.75rem 1rem;
            background: var(--bg-secondary);
            border-bottom: 2px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .track-column-cards {
            padding: 0.75rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        /* Untracked Section */
        .untracked-section {
            margin-top: 2rem;
            background: var(--bg-secondary);
            border: 2px solid var(--border-strong);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: var(--shadow-md);
            display: flex;
            flex-direction: column;
            grid-column: 1 / -1;
            align-self: stretch;
            min-height: 0;
        }

        .untracked-header {
            padding: 1rem 1.5rem;
            background: var(--bg-tertiary);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            transition: background 0.2s;
            border-bottom: 2px solid var(--border);
        }

        .untracked-header:hover {
            background: var(--border);
        }

        .untracked-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .untracked-icon {
            font-size: 1.5rem;
        }

        .untracked-title h3 {
            margin: 0;
            color: #ff9500;
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.125rem;
            font-weight: 600;
        }

        .untracked-meta {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .untracked-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s var(--ease-out-expo);
            flex-grow: 0;
        }

        .untracked-content.collapsed {
            max-height: 0;
        }

        .untracked-section.expanded .untracked-content {
            max-height: none;
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        /* Empty state */
        .empty-state {
            padding: 4rem 2rem;
            text-align: center;
            color: var(--text-muted);
            font-size: 1.125rem;
        }

        /* ================================================================
           CARDS
           ================================================================ */
        .card {
            background: var(--bg-primary);
            border: 2px solid var(--border-strong);
            padding: 1rem;
            cursor: pointer;
            transition: all 0.2s var(--ease-out-expo);
            box-shadow: var(--shadow-sm);
            position: relative;
            animation: cardReveal 0.4s var(--ease-out-expo) backwards;
        }

        @keyframes cardReveal {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
        }

        .card:hover {
            transform: translate(-4px, -4px);
            box-shadow: var(--shadow-hover);
        }

        .card:active {
            transform: translate(0, 0);
            box-shadow: none;
        }

        .card::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: var(--priority-medium);
        }

        .card.priority-critical::before { background: var(--priority-critical); }
        .card.priority-high::before { background: var(--priority-high); }
        .card.priority-medium::before { background: var(--priority-medium); }
        .card.priority-low::before { background: var(--priority-low); }

        .card-title {
            font-weight: 600;
            font-size: 0.9375rem;
            margin-bottom: 0.75rem;
            line-height: 1.3;
        }

        .card-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
        }

        .badge {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.625rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 0.25rem 0.5rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
        }

        .badge.priority-critical { background: var(--priority-critical); color: white; border-color: var(--priority-critical); }
        .badge.priority-high { background: var(--priority-high); color: white; border-color: var(--priority-high); }
        .badge.type { background: var(--accent); color: var(--accent-text); border-color: var(--accent); }

        /* Agent attribution badges - color-coded by agent type */
        .badge.agent {
            padding: 0.375rem 0.625rem;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            position: relative;
            transition: all 0.2s ease;
            cursor: help;
        }

        .badge.agent::before {
            content: '';
            display: inline-block;
            width: 0.5rem;
            height: 0.5rem;
            border-radius: 50%;
            background: currentColor;
            opacity: 0.8;
        }

        .badge.agent:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        /* Primary agents - Requested color system */
        .badge.agent-claude { background: #2979FF; color: white; border-color: #2979FF; }
        .badge.agent-codex { background: #00C853; color: white; border-color: #00C853; }
        .badge.agent-orchestrator { background: #7C4DFF; color: white; border-color: #7C4DFF; }
        .badge.agent-gemini { background: #FBC02D; color: #000; border-color: #FBC02D; }
        .badge.agent-gemini-2 { background: #FF9100; color: white; border-color: #FF9100; }

        /* Secondary agents - Backward compatibility */
        .badge.agent-analyst { background: #7C3AED; color: white; border-color: #7C3AED; }
        .badge.agent-developer { background: #00C853; color: white; border-color: #00C853; }
        .badge.agent-researcher { background: #FF6D00; color: white; border-color: #FF6D00; }
        .badge.agent-debugger { background: #E91E63; color: white; border-color: #E91E63; }
        .badge.agent-default { background: #78909C; color: white; border-color: #78909C; }

        /* Delegation badges */
        .badge.delegation { padding: 0.25rem 0.5rem; font-size: 0.55rem; }
        .badge.delegation-external { background: #00C853; color: white; }
        .badge.delegation-fallback { background: #FF9100; color: white; }
        .badge.delegation-direct { background: #2979FF; color: white; }

        .card-path {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.625rem;
            color: var(--text-muted);
            margin-left: auto;
        }

        .empty-column {
            text-align: center;
            padding: 2rem 1rem;
            color: var(--text-muted);
            font-size: 0.875rem;
            border: 2px dashed var(--border);
            margin: 1rem;
        }

        /* ================================================================
           ANALYTICS VIEW
           ================================================================ */
        .analytics {
            display: none;
            margin-top: 1.5rem;
        }

        .analytics.active {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            overflow: auto;
        }

        /* ================================================================
           SESSIONS VIEW
           ================================================================ */
        .sessions {
            display: none;
            margin-top: 1.5rem;
        }

        .sessions.active {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            overflow: auto;
        }

        /* ================================================================
           AGENTS VIEW - Multi-Agent Work Attribution
           ================================================================ */
        .agents {
            display: none;
            margin-top: 1.5rem;
            padding: 0 1.5rem 1.5rem 1.5rem;
        }

        .agents.active {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            overflow: auto;
        }

        .agent-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .agent-stat-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
            text-align: center;
            box-shadow: var(--shadow-sm);
        }

        .agent-stat-card h4 {
            color: var(--text-muted);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .agent-stat-value {
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
        }

        .agent-stat-unit {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }

        /* ================================================================
           WORKLOAD DISTRIBUTION CHART
           ================================================================ */
        .workload-chart-container {
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: var(--shadow-sm);
            margin-top: 1rem;
        }

        .workload-chart-header {
            margin-bottom: 1.5rem;
        }

        .workload-chart-header h3 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-muted);
            margin-bottom: 0.25rem;
            font-weight: 600;
        }

        .workload-chart-header p {
            color: var(--text-secondary);
            font-size: 0.875rem;
            margin: 0;
        }

        .workload-bars {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            max-height: 600px;
            overflow-y: auto;
        }

        .workload-bar-group {
            display: flex;
            flex-direction: column;
            gap: 0.375rem;
        }

        .workload-bar-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
        }

        .workload-bar-label-name {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
        }

        .workload-agent-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            font-size: 0.7rem;
            font-weight: 600;
            color: white;
            flex-shrink: 0;
        }

        .workload-bar-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: var(--text-muted);
            white-space: nowrap;
        }

        .workload-bar-container {
            position: relative;
            width: 100%;
            height: 32px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            overflow: hidden;
        }

        .workload-bar-fill {
            height: 100%;
            display: flex;
            align-items: center;
            padding: 0 0.75rem;
            transition: all 0.3s var(--ease-out-expo);
            position: relative;
            justify-content: flex-start;
        }

        .workload-bar-fill::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0) 100%);
            pointer-events: none;
        }

        .workload-bar-text {
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: white;
            font-size: 0.75rem;
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
            white-space: nowrap;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            pointer-events: none;
            z-index: 2;
        }

        .workload-bar-hover-info {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-tertiary);
            border: 1px solid var(--border-strong);
            border-radius: 4px;
            padding: 0.75rem;
            font-size: 0.75rem;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
            z-index: 100;
            margin-bottom: 0.5rem;
            box-shadow: var(--shadow-md);
        }

        .workload-bar-container:hover .workload-bar-hover-info {
            opacity: 1;
            visibility: visible;
        }

        .workload-bar-hover-info::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: var(--border-strong);
        }

        .workload-chart-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border);
            font-size: 0.875rem;
        }

        .workload-legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .workload-legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .workload-legend-label {
            color: var(--text-secondary);
        }

        /* Agent Color System */
        .agent-claude { background: linear-gradient(135deg, #6366f1, #818cf8); }
        .agent-codex { background: linear-gradient(135deg, #10b981, #34d399); }
        .agent-orchestrator { background: linear-gradient(135deg, #f59e0b, #fbbf24); }
        .agent-gemini-2 { background: linear-gradient(135deg, #8b5cf6, #a78bfa); }
        .agent-gemini { background: linear-gradient(135deg, #ec4899, #f472b6); }
        .agent-analyst { background: linear-gradient(135deg, #0ea5e9, #38bdf8); }
        .agent-developer { background: linear-gradient(135deg, #06b6d4, #22d3ee); }

        /* ================================================================
           AGENT COST VISUALIZATION
           ================================================================ */
        .cost-breakdown-container {
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: var(--shadow-sm);
            margin-top: 1rem;
        }

        .cost-breakdown-header {
            margin-bottom: 1.5rem;
        }

        .cost-breakdown-header h3 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-muted);
            margin-bottom: 0.25rem;
            font-weight: 600;
        }

        .cost-breakdown-header p {
            color: var(--text-secondary);
            font-size: 0.875rem;
            margin: 0;
        }

        .cost-summary-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .cost-metric {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 1rem;
            text-align: center;
        }

        .cost-metric-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .cost-metric-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .cost-metric-unit {
            font-size: 0.65rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }

        .cost-bars {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
            max-height: 600px;
            overflow-y: auto;
        }

        .cost-bar-group {
            display: flex;
            flex-direction: column;
            gap: 0.375rem;
        }

        .cost-bar-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 0.375rem;
        }

        .cost-bar-label-name {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
        }

        .cost-agent-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            font-size: 0.7rem;
            font-weight: 600;
            color: white;
            flex-shrink: 0;
        }

        .cost-bar-stats {
            display: flex;
            gap: 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }

        .cost-bar-stat {
            display: flex;
            flex-direction: column;
            gap: 0.125rem;
        }

        .cost-bar-stat-label {
            color: var(--text-muted);
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .cost-bar-stat-value {
            color: var(--text-primary);
            font-weight: 600;
        }

        .cost-bar-container {
            position: relative;
            width: 100%;
            height: 40px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            overflow: hidden;
        }

        .cost-bar-stacked {
            display: flex;
            height: 100%;
            width: 100%;
            position: relative;
            overflow: hidden;
        }

        .cost-bar-segment {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.3s var(--ease-out-expo);
            flex-grow: 1;
            min-width: 2px;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
        }

        .cost-bar-segment:last-child {
            border-right: none;
        }

        .cost-bar-segment::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, rgba(255,255,255,0.25) 0%, rgba(255,255,255,0) 100%);
            pointer-events: none;
        }

        .cost-bar-segment-label {
            position: relative;
            z-index: 2;
            font-size: 0.65rem;
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            white-space: nowrap;
            padding: 0 0.3rem;
            pointer-events: none;
        }

        .cost-bar-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-tertiary);
            border: 1px solid var(--border-strong);
            border-radius: 4px;
            padding: 0.75rem;
            font-size: 0.75rem;
            pointer-events: none;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
            z-index: 100;
            margin-bottom: 0.5rem;
            box-shadow: var(--shadow-md);
            white-space: nowrap;
        }

        .cost-bar-segment:hover ~ .cost-bar-tooltip,
        .cost-bar-container:hover .cost-bar-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .cost-bar-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: var(--border-strong);
        }

        .cost-range-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }

        .cost-range-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .cost-range-dot.low { background: #10b981; }
        .cost-range-dot.medium { background: #f59e0b; }
        .cost-range-dot.high { background: #ef4444; }

        .cost-breakdown-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border);
            font-size: 0.875rem;
        }

        .cost-legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .cost-legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .cost-legend-label {
            color: var(--text-secondary);
        }

        /* Agent cost colors - match agent system */
        .cost-claude { background: #2979FF; }
        .cost-codex { background: #00C853; }
        .cost-orchestrator { background: #7C4DFF; }
        .cost-gemini { background: #FBC02D; }
        .cost-gemini-2 { background: #FF9100; }
        .agent-researcher { background: linear-gradient(135deg, #d946ef, #e879f9); }
        .agent-debugger { background: linear-gradient(135deg, #ef4444, #f87171); }
        .agent-default { background: linear-gradient(135deg, #6b7280, #9ca3af); }

        .workload-empty-state {
            text-align: center;
            padding: 2rem;
            color: var(--text-muted);
        }

        .workload-empty-state svg {
            width: 48px;
            height: 48px;
            margin: 0 auto 1rem;
            opacity: 0.5;
        }

        .workload-chart-responsive {
            max-height: 500px;
            overflow-y: auto;
        }

        @media (max-width: 768px) {
            .workload-bar-group {
                gap: 0.25rem;
            }

            .workload-bar-label {
                font-size: 0.8rem;
            }

            .workload-bar-text {
                font-size: 0.65rem;
            }

            .workload-chart-legend {
                gap: 1rem;
            }

            .workload-bars {
                max-height: 400px;
            }
        }

        /* Skills Matrix Styles */
        .skills-matrix-container {
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: var(--shadow-sm);
            overflow-x: auto;
        }

        .skills-matrix {
            display: grid;
            grid-template-columns: 150px repeat(auto-fit, minmax(100px, 1fr));
            gap: 0;
            min-width: 600px;
        }

        .skills-matrix-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.75rem;
            border: 1px solid var(--border);
            font-size: 0.85rem;
            min-height: 50px;
        }

        .skills-matrix-header-row {
            position: sticky;
            top: 0;
            background: var(--bg-tertiary);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            font-size: 0.75rem;
            z-index: 10;
        }

        .skills-matrix-agent-name {
            position: sticky;
            left: 0;
            background: var(--bg-tertiary);
            font-weight: 600;
            color: var(--text-primary);
            text-align: left;
            z-index: 11;
        }

        .skills-matrix-skill-label {
            writing-mode: horizontal-tb;
            white-space: nowrap;
        }

        .proficiency-dot {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            font-size: 0.7rem;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: help;
        }

        .proficiency-dot:hover {
            transform: scale(1.15);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .proficiency-1 {
            background: #fee5e5;
            color: #8b0000;
            border: 1px solid #d4a5a5;
        }

        .proficiency-2 {
            background: #ffcccb;
            color: #660000;
            border: 1px solid #c97c7c;
        }

        .proficiency-3 {
            background: #ffb366;
            color: #5a3a00;
            border: 1px solid #cc8844;
        }

        .proficiency-4 {
            background: #99ff99;
            color: #1a4d1a;
            border: 1px solid #66cc66;
        }

        .proficiency-5 {
            background: #00cc00;
            color: #ffffff;
            border: 1px solid #009900;
        }

        .skill-category-legend {
            display: flex;
            gap: 1.5rem;
            flex-wrap: wrap;
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border);
        }

        .skill-category-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
        }

        .skill-category-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            border-radius: 3px;
            background: var(--accent);
        }

        .skill-tooltip {
            position: absolute;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-strong);
            border-radius: 4px;
            padding: 0.5rem 0.75rem;
            font-size: 0.75rem;
            white-space: nowrap;
            pointer-events: none;
            z-index: 1000;
            box-shadow: var(--shadow-md);
        }

        /* ================================================================
           TRACKS VIEW
           ================================================================ */
        .tracks {
            display: none;
        }

        .tracks.active {
            display: block;
        }

        .sessions-table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            background: var(--bg-secondary);
            border: 2px solid var(--border-strong);
            box-shadow: var(--shadow-md);
        }

        .sessions-table th,
        .sessions-table td {
            border-bottom: 1px solid var(--border);
            padding: 0.875rem 1rem;
            text-align: left;
            vertical-align: middle;
        }

        .sessions-table th {
            color: var(--text-muted);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-size: 0.625rem;
            background: var(--bg-tertiary);
            border-bottom: 2px solid var(--border-strong);
        }

        .sessions-table tr:hover td {
            background: var(--bg-tertiary);
        }

        .sessions-table .session-id {
            font-weight: 600;
            color: var(--status-active);
            cursor: pointer;
            text-decoration: underline;
            text-underline-offset: 2px;
        }

        .sessions-table .session-id:hover {
            color: var(--accent);
        }

        /* Session Filters */
        .session-filters {
            display: flex;
            gap: 1rem;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border: 2px solid var(--border-strong);
            box-shadow: var(--shadow-md);
            margin-bottom: 1rem;
            flex-wrap: wrap;
            align-items: flex-end;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.375rem;
        }

        .filter-group label {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .filter-select,
        .filter-input {
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border);
            background: var(--bg-primary);
            color: var(--text-primary);
            border-radius: 4px;
            font-size: 0.875rem;
            font-family: 'JetBrains Mono', monospace;
            min-width: 150px;
        }

        .filter-select:focus,
        .filter-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.1);
        }

        .filter-input::placeholder {
            color: var(--text-muted);
            opacity: 0.6;
        }

        .analytics-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 1rem;
            padding: 1.25rem 1.5rem;
            background: var(--bg-secondary);
            border: 2px solid var(--border-strong);
            box-shadow: var(--shadow-md);
            margin-bottom: 1rem;
        }

        .analytics-header h2 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: 0.25rem;
        }

        .analytics-header p {
            color: var(--text-muted);
            font-size: 0.875rem;
            margin: 0;
        }

        .analytics-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
        }

        /* Timeline is always full width and first */
        .analytics-grid > #analytics-timeline {
            grid-column: 1 / -1;
            order: -10;
        }

        /* Summary metrics grid: 3 columns */
        .analytics-grid > #analytics-summary {
            grid-column: 1 / -1;
            order: -9;
        }

        /* Collaboration metrics: 2 columns */
        .analytics-grid > #analytics-collaboration {
            grid-column: 1 / -1;
            order: -8;
        }

        /* Feature and tool analysis: 2 columns each */
        .analytics-grid > #analytics-features,
        .analytics-grid > #analytics-tools {
            order: -7;
        }

        /* Commit DAG: full width */
        .analytics-grid > #analytics-commit-dag {
            grid-column: 1 / -1;
            order: -6;
        }

        @media (max-width: 1200px) {
            .analytics-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .analytics-grid {
                gap: 1rem;
            }
        }

        .analytics-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border-strong);
            box-shadow: var(--shadow-md);
            padding: 1rem 1.25rem;
        }

        .analytics-card h3 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            margin-bottom: 0.75rem;
        }

        .analytics-card-wide {
            grid-column: 1 / -1;
        }

        /* Timeline Section */
        .analytics-timeline {
            background: var(--bg-secondary);
            border: 2px solid var(--border-strong);
            box-shadow: var(--shadow-md);
            padding: 1.5rem;
            position: relative;
        }

        .timeline-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .timeline-header h3 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
        }

        .timeline-header .timeline-legend {
            display: flex;
            gap: 1.5rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .timeline-legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .timeline-legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .timeline-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            max-height: 400px;
            overflow-y: auto;
        }

        .timeline-entry {
            display: flex;
            gap: 1rem;
            padding: 0.875rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            transition: all 0.2s var(--ease-out-expo);
            cursor: pointer;
        }

        .timeline-entry:hover {
            background: var(--bg-secondary);
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(205, 255, 0, 0.1);
        }

        .timeline-entry-marker {
            flex-shrink: 0;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-top: 3px;
            border: 2px solid var(--border-strong);
        }

        .timeline-entry-marker.session { background: var(--status-active); }
        .timeline-entry-marker.feature { background: var(--accent); }
        .timeline-entry-marker.commit { background: var(--status-done); }
        .timeline-entry-marker.error { background: var(--status-blocked); }

        .timeline-entry-content {
            flex: 1;
            min-width: 0;
        }

        .timeline-entry-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .timeline-entry-meta {
            display: flex;
            gap: 1rem;
            font-size: 0.75rem;
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
        }

        /* Summary/Health Indicators */
        .analytics-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .health-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border-strong);
            box-shadow: var(--shadow-md);
            padding: 1.5rem;
            position: relative;
        }

        .health-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
        }

        .health-card.health-good::before { background: var(--status-done); }
        .health-card.health-ok::before { background: var(--priority-high); }
        .health-card.health-poor::before { background: var(--status-blocked); }

        .health-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.625rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
        }

        .health-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
        }

        .health-detail {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border);
        }

        /* Collaboration Metrics */
        .collaboration-metrics {
            background: var(--bg-secondary);
            border: 2px solid var(--border-strong);
            box-shadow: var(--shadow-md);
            padding: 1.5rem;
        }

        .collaboration-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .collab-stat {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding: 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
        }

        .collab-stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .collab-stat-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-muted);
        }

        /* Commit DAG Visualization */
        .commit-dag-container {
            position: relative;
            width: 100%;
            height: 400px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            overflow: hidden;
        }

        .commit-dag-svg {
            width: 100%;
            height: 100%;
        }

        .commit-dag-svg .commit-node {
            cursor: pointer;
            transition: transform 0.15s ease;
        }

        .commit-dag-svg .commit-node:hover {
            transform: scale(1.1);
        }

        .commit-dag-svg .commit-node circle {
            stroke-width: 2px;
            stroke: var(--border-strong);
        }

        .commit-dag-svg .commit-node.merge circle {
            stroke-width: 3px;
            stroke: var(--priority-medium);
        }

        .commit-dag-svg .commit-node.external circle {
            stroke-dasharray: 4 2;
            opacity: 0.6;
        }

        .commit-dag-svg .commit-node text {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            fill: var(--text-primary);
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
        }

        .commit-dag-svg .commit-edge {
            stroke: var(--text-muted);
            stroke-width: 2px;
            fill: none;
        }

        .commit-dag-svg .commit-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            fill: var(--text-secondary);
        }

        .commit-dag-svg .branch-label {
            font-family: 'Outfit', sans-serif;
            font-size: 11px;
            fill: var(--accent-dim);
            font-weight: 600;
        }

        .commit-dag-legend {
            display: flex;
            gap: 1rem;
            margin-top: 0.75rem;
            font-size: 0.7rem;
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-muted);
        }

        .commit-dag-legend-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .commit-dag-legend-item .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 2px solid var(--border-strong);
        }

        .commit-dag-legend-item .dot.large {
            background: var(--status-active);
        }

        .commit-dag-legend-item .dot.small {
            background: var(--status-todo);
            width: 8px;
            height: 8px;
        }

        .commit-dag-legend-item .dot.external {
            border-style: dashed;
            opacity: 0.6;
        }

        .analytics-kpis {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
        }

        @media (max-width: 700px) {
            .analytics-kpis {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .kpi {
            border: 2px solid var(--border-strong);
            background: var(--bg-secondary);
            padding: 1.25rem;
            box-shadow: var(--shadow-sm);
            position: relative;
            overflow: hidden;
        }

        .kpi::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--accent);
        }

        .kpi.healthy::before { background: var(--status-done); }
        .kpi.warning::before { background: var(--priority-high); }
        .kpi.critical::before { background: var(--priority-critical); }

        .kpi .kpi-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .kpi .kpi-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.625rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            margin-top: 0.5rem;
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }

        .table th, .table td {
            border-bottom: 1px solid var(--border);
            padding: 0.5rem 0.25rem;
            text-align: left;
            vertical-align: top;
        }

        .table th {
            color: var(--text-muted);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-size: 0.625rem;
        }

        .table tr:hover td {
            background: var(--bg-tertiary);
        }

        .table .mono {
            font-family: 'JetBrains Mono', monospace;
        }

        .feature-link {
            border: none;
            background: none;
            padding: 0;
            color: var(--text-primary);
            cursor: pointer;
            text-decoration: underline;
            text-underline-offset: 2px;
        }

        .feature-link:hover {
            color: var(--status-active);
        }

        .analytics-note {
            color: var(--text-muted);
            font-size: 0.875rem;
            margin-top: 0.5rem;
        }

        /* ================================================================
           DETAIL PANEL
           ================================================================ */
        .panel-overlay {
            position: fixed;
            inset: 0;
            background: rgba(10, 10, 10, 0.6);
            backdrop-filter: blur(4px);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s var(--ease-out-expo);
            z-index: 100;
        }

        .panel-overlay.open {
            opacity: 1;
            visibility: visible;
        }

        .panel {
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            width: 520px;
            max-width: 100%;
            background: var(--bg-secondary);
            border-left: 2px solid var(--border-strong);
            transform: translateX(100%);
            transition: transform 0.4s var(--ease-spring);
            z-index: 101;
            display: flex;
            flex-direction: column;
        }

        .panel.open {
            transform: translateX(0);
        }

        .panel-header {
            padding: 1.5rem;
            border-bottom: 2px solid var(--border-strong);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 1rem;
            background: var(--bg-tertiary);
        }

        .panel-header h2 {
            font-size: 1.25rem;
            font-weight: 700;
            line-height: 1.3;
            flex: 1;
        }

        .panel-close {
            width: 40px;
            height: 40px;
            border: 2px solid var(--border-strong);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s var(--ease-out-expo);
            flex-shrink: 0;
        }

        .panel-close:hover {
            background: var(--accent);
            color: var(--accent-text);
        }

        .panel-body {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }

        .panel-section {
            margin-bottom: 2rem;
        }

        .panel-section:last-child {
            margin-bottom: 0;
        }

        .panel-section h3 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.625rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--text-muted);
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .panel-meta {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .panel-meta .badge {
            font-size: 0.75rem;
            padding: 0.375rem 0.625rem;
        }

        /* Steps */
        .steps-list {
            list-style: none;
        }

        .step-item {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            padding: 0.75rem 0;
            border-bottom: 1px solid var(--border);
        }

        .step-item:last-child {
            border-bottom: none;
        }

        .step-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: var(--accent);
            flex-shrink: 0;
            margin-top: 2px;
        }

        .step-text {
            flex: 1;
            font-size: 0.9375rem;
        }

        .step-text.completed {
            text-decoration: line-through;
            color: var(--text-muted);
        }

        .step-agent {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6875rem;
            color: var(--text-muted);
        }

        /* Activity Log */
        .activity-header {
            margin-bottom: 1rem;
            font-size: 0.875rem;
            color: var(--text-muted);
        }

        .activity-list {
            list-style: none;
            max-height: 600px;
            overflow-y: auto;
            padding-right: 0.5rem;
        }

        .activity-item {
            padding: 0.875rem 0;
            border-bottom: 1px solid var(--border);
            font-size: 0.8125rem;
        }

        .activity-item:last-child {
            border-bottom: none;
        }

        .activity-meta {
            display: flex;
            align-items: center;
            gap: 0.625rem;
            margin-bottom: 0.375rem;
            flex-wrap: wrap;
        }

        .activity-time {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6875rem;
            color: var(--text-muted);
        }

        .activity-tool {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .activity-content {
            font-size: 0.8125rem;
            color: var(--text-secondary);
            word-wrap: break-word;
        }

        .badge.drift-high {
            background: var(--status-blocked);
        }

        .badge.drift-low {
            background: var(--status-done);
        }

        /* Edges */
        .edge-list {
            list-style: none;
        }

        .edge-item {
            padding: 0.5rem 0;
        }

        .edge-item a {
            color: var(--status-active);
            text-decoration: none;
            font-weight: 500;
            cursor: pointer;
            transition: color 0.2s;
        }

        .edge-item a:hover {
            color: var(--accent);
        }

        .edge-type {
            font-family: 'JetBrains Mono', monospace;
        }

        /* Delegations */
        .delegations-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .delegation-item {
            padding: 0.75rem;
            border: 1px solid var(--border);
            background: var(--bg-tertiary);
            border-radius: 2px;
        }

        .delegation-meta {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .delegation-task {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.375rem;
        }

        .delegation-time {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-muted);
        }

        .mono {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        /* Session Activity Preview */
        .session-preview {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            margin-top: 0.75rem;
            overflow: hidden;
        }

        .session-preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0.75rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            cursor: pointer;
        }

        .session-preview-header:hover {
            background: var(--bg-tertiary);
        }

        .session-preview-title {
            font-weight: 600;
            font-size: 0.8125rem;
        }

        .session-preview-meta {
            display: flex;
            gap: 0.5rem;
            font-size: 0.6875rem;
            color: var(--text-muted);
        }

        .session-preview-body {
            max-height: 200px;
            overflow-y: auto;
            padding: 0.5rem 0;
        }

        .session-preview-body.collapsed {
            display: none;
        }

        .activity-entry {
            display: flex;
            gap: 0.5rem;
            padding: 0.375rem 0.75rem;
            font-size: 0.75rem;
            border-bottom: 1px solid var(--border);
        }

        .activity-entry:last-child {
            border-bottom: none;
        }

        .activity-tool {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            color: var(--status-active);
            min-width: 70px;
        }

        .activity-tool.Edit { color: var(--priority-high); }
        .activity-tool.Bash { color: var(--status-done); }
        .activity-tool.Read { color: var(--text-muted); }
        .activity-tool.UserQuery { color: var(--priority-critical); }

        .activity-summary {
            color: var(--text-secondary);
            flex: 1;
        }

        .activity-time {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.625rem;
            color: var(--text-muted);
        }

        .drift-warning {
            color: var(--priority-high);
            font-size: 0.625rem;
            font-size: 0.6875rem;
            color: var(--text-muted);
            margin-left: 0.5rem;
        }

        /* Activity Feed Table View */
        .activity-list.table-view {
            flex: 1;
            min-height: 0;
            overflow: auto;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
        }

        .activity-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8125rem;
            background: var(--bg-secondary);
        }

        .activity-table thead {
            position: sticky;
            top: 0;
            background: var(--bg-tertiary);
            border-bottom: 2px solid var(--border-strong);
            z-index: 10;
        }

        .activity-table th {
            padding: 0.875rem 1rem;
            text-align: left;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 0.6875rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            white-space: nowrap;
            border-right: 1px solid var(--border);
            user-select: none;
        }

        .activity-table th:last-child {
            border-right: none;
        }

        .activity-table th.col-timestamp {
            cursor: pointer;
            transition: background 0.2s;
        }

        .activity-table th.col-timestamp:hover {
            background: var(--bg-secondary);
            color: var(--accent);
        }

        .activity-table tbody tr {
            border-bottom: 1px solid var(--border);
            transition: background-color 0.2s;
        }

        .activity-table tbody tr:hover {
            background-color: var(--bg-tertiary);
        }

        /* Alternating row colors for readability */
        .activity-table tbody tr:nth-child(even) {
            background-color: var(--bg-primary);
        }

        .activity-table tbody tr:nth-child(even):hover {
            background-color: var(--bg-tertiary);
        }

        /* Parent rows slightly emphasized */
        .activity-table tbody tr.parent-row {
            font-weight: 500;
            border-left: 3px solid var(--accent);
        }

        /* Child rows with visual indent marker */
        .activity-table tbody tr.child-row {
            background-color: rgba(205, 255, 0, 0.02);
            border-left: 3px solid var(--text-muted);
        }

        .activity-table tbody tr.child-row:hover {
            background-color: rgba(205, 255, 0, 0.05);
        }

        /* Status-based row coloring */
        .activity-table tbody tr.event-recorded {
            border-left-color: var(--status-done);
        }

        .activity-table tbody tr.event-pending {
            border-left-color: var(--priority-medium);
        }

        .activity-table tbody tr.event-error {
            border-left-color: var(--status-blocked);
        }

        .activity-table td {
            padding: 0.75rem 1rem;
            color: var(--text-secondary);
            border-right: 1px solid var(--border);
            vertical-align: top;
        }

        .activity-table td:last-child {
            border-right: none;
        }

        /* Column widths */
        .activity-table .col-timestamp {
            width: 180px;
            min-width: 180px;
        }

        .activity-table .col-agent {
            width: 120px;
            min-width: 120px;
        }

        .activity-table .col-tool {
            width: 100px;
            min-width: 100px;
        }

        .activity-table .col-input {
            width: 180px;
            min-width: 180px;
        }

        .activity-table .col-output {
            width: 180px;
            min-width: 180px;
        }

        .activity-table .col-status {
            width: 90px;
            min-width: 90px;
        }

        .activity-table .col-id {
            width: 80px;
            min-width: 80px;
        }

        /* Table cell content styling */
        .activity-table .event-type-badge {
            font-size: 1rem;
            margin-right: 0.5rem;
            display: inline-block;
            vertical-align: middle;
        }

        .activity-table .timestamp-text {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-muted);
            white-space: nowrap;
        }

        .activity-table .agent-badge {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            background: var(--bg-tertiary);
            padding: 0.25rem 0.5rem;
            border-radius: 2px;
            margin-right: 0.25rem;
        }

        .activity-table .parent-indicator {
            font-size: 0.875rem;
            margin-left: 0.25rem;
            opacity: 0.7;
        }

        .activity-table .child-indicator {
            font-size: 0.875rem;
            margin-left: 0.25rem;
            opacity: 0.6;
            color: var(--text-muted);
        }

        .activity-table .tool-name {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            background: var(--bg-tertiary);
            padding: 0.25rem 0.5rem;
            border-radius: 2px;
            color: var(--status-active);
            word-break: break-all;
        }

        .activity-table .truncate {
            display: inline-block;
            max-width: 100%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }

        .activity-table .text-muted {
            color: var(--text-muted);
            font-style: italic;
        }

        .activity-table .status-badge {
            display: inline-block;
            padding: 0.375rem 0.625rem;
            border-radius: 2px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .activity-table .status-badge.status-recorded {
            background: rgba(0, 200, 83, 0.15);
            color: var(--status-done);
            border: 1px solid var(--status-done);
        }

        .activity-table .status-badge.status-pending {
            background: rgba(41, 121, 255, 0.15);
            color: var(--priority-medium);
            border: 1px solid var(--priority-medium);
        }

        .activity-table .status-badge.status-error {
            background: rgba(255, 23, 68, 0.15);
            color: var(--status-blocked);
            border: 1px solid var(--status-blocked);
        }

        .activity-table .event-id-code {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-muted);
            cursor: pointer;
            transition: color 0.2s;
            word-break: break-all;
        }

        .activity-table .event-id-code:hover {
            color: var(--accent);
        }

        /* Responsive table scrolling */
        @media (max-width: 1200px) {
            .activity-table .col-input,
            .activity-table .col-output {
                width: 120px;
                min-width: 120px;
            }
        }

        @media (max-width: 768px) {
            .activity-table {
                font-size: 0.75rem;
            }

            .activity-table th,
            .activity-table td {
                padding: 0.5rem 0.75rem;
            }

            .activity-table .col-timestamp {
                width: 140px;
                min-width: 140px;
            }

            .activity-table .col-input,
            .activity-table .col-output {
                width: 100px;
                min-width: 100px;
            }
        }

        /* Content */
        .panel-content {
            line-height: 1.7;
            color: var(--text-secondary);
        }

        .panel-content p {
            margin-bottom: 1rem;
        }

        .panel-content ul, .panel-content ol {
            margin-bottom: 1rem;
            padding-left: 1.5rem;
        }

        .panel-timestamps {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        /* Actions */
        .panel-actions {
            padding: 1rem 1.5rem;
            border-top: 2px solid var(--border-strong);
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            background: var(--bg-tertiary);
        }

        .btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 0.75rem 1.25rem;
            border: 2px solid var(--border-strong);
            background: var(--bg-secondary);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s var(--ease-out-expo);
            box-shadow: var(--shadow-sm);
        }

        .btn:hover {
            transform: translate(-2px, -2px);
            box-shadow: var(--shadow-md);
        }

        .btn:active {
            transform: translate(0, 0);
            box-shadow: none;
        }

        .btn-primary {
            background: var(--accent);
            color: var(--accent-text);
            border-color: var(--accent);
        }

        .btn-success {
            background: var(--status-done);
            color: white;
            border-color: var(--status-done);
        }

        .btn-warning {
            background: var(--priority-high);
            color: white;
            border-color: var(--priority-high);
        }

        .btn-danger {
            background: var(--status-blocked);
            color: white;
            border-color: var(--status-blocked);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Loading */
        .loading {
            text-align: center;
            padding: 3rem;
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
        }

        /* ================================================================
           SPEC/PLAN MODAL VIEWER - Slide-in Panel
           ================================================================ */
        .spec-plan-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 9999;
            display: none;
            opacity: 0;
            transition: opacity 0.3s var(--ease-out-expo);
        }

        .spec-plan-modal.active {
            display: flex;
            opacity: 1;
        }

        .spec-plan-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            cursor: pointer;
        }

        .spec-plan-panel {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 90%;
            max-width: 1400px;
            background: var(--bg-primary);
            box-shadow: -8px 0 32px rgba(0, 0, 0, 0.5);
            transform: translateX(100%);
            transition: transform 0.4s var(--ease-out-expo);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .spec-plan-modal.active .spec-plan-panel {
            transform: translateX(0);
        }

        .spec-plan-header {
            background: var(--bg-secondary);
            border-bottom: 2px solid var(--border);
            padding: 1.5rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .spec-plan-breadcrumb {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .spec-plan-breadcrumb a {
            color: var(--text-secondary);
            text-decoration: none;
            transition: color 0.2s;
        }

        .spec-plan-breadcrumb a:hover {
            color: var(--accent);
        }

        .spec-plan-breadcrumb .separator {
            color: var(--text-muted);
        }

        .spec-plan-breadcrumb .current {
            color: var(--accent);
            font-weight: 600;
        }

        .spec-plan-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .spec-plan-toggle {
            display: flex;
            gap: 0.5rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 4px;
        }

        .spec-plan-toggle button {
            padding: 0.5rem 1rem;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .spec-plan-toggle button:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .spec-plan-toggle button.active {
            background: var(--accent);
            color: var(--accent-text);
            font-weight: 600;
        }

        .spec-plan-close {
            width: 36px;
            height: 36px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .spec-plan-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            transform: scale(1.1);
        }

        .spec-plan-content {
            flex: 1;
            overflow-y: auto;
            padding: 2rem;
        }

        .spec-plan-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 400px;
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
        }

        .spec-plan-error {
            text-align: center;
            padding: 3rem;
            color: var(--status-blocked);
            font-family: 'JetBrains Mono', monospace;
        }

        /* Content styling within modal */
        .spec-plan-content article {
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Make sure nested styles inherit properly */
        .spec-plan-content h1,
        .spec-plan-content h2,
        .spec-plan-content h3 {
            color: var(--text-primary);
        }

        .spec-plan-content .badge {
            font-family: 'JetBrains Mono', monospace;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .spec-plan-panel {
                width: 100%;
                max-width: 100%;
            }

            .spec-plan-header {
                padding: 1rem 1.5rem;
            }

            .spec-plan-breadcrumb {
                font-size: 0.75rem;
            }

            .spec-plan-toggle {
                display: none; /* Hide toggle on mobile, show only close */
            }

            .spec-plan-content {
                padding: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <div class="brand">
                <h1 class="brand-title">HtmlGraph</h1>
                <p class="brand-tagline">HTML is All You Need</p>
            </div>
            <div class="header-actions">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon">&#9788;</span>
                </button>
            </div>
        </header>

        <!-- View Toggle -->
        <div class="view-toggle">
            <button class="view-btn active" data-view="kanban">Work</button>
            <button class="view-btn" data-view="analytics">Analytics</button>
            <button class="view-btn" data-view="agents">Agents</button>
            <button class="view-btn" data-view="sessions">Sessions</button>
        </div>

        <!-- Features View (Track-Grouped Kanban) -->
        <div class="kanban active" id="kanban"></div>

        <!-- Analytics View -->
        <div class="analytics" id="analytics">
            <div class="analytics-header">
                <div>
                    <h2>Analytics</h2>
                    <p>Powered by `.htmlgraph/index.sqlite` (rebuildable cache) generated from Git-friendly event logs.</p>
                </div>
                <div style="display:flex; gap:0.5rem; align-items:center;">
                    <button class="btn btn-primary" id="analytics-refresh">Refresh</button>
                </div>
            </div>

            <div class="analytics-grid">
                <!-- Timeline: Primary Focus -->
                <div class="analytics-timeline" id="analytics-timeline">
                    <div class="timeline-header">
                        <h3>Activity Timeline</h3>
                        <div class="timeline-legend">
                            <div class="timeline-legend-item">
                                <div class="timeline-legend-dot" style="background: var(--status-active);"></div>
                                <span>Sessions</span>
                            </div>
                            <div class="timeline-legend-item">
                                <div class="timeline-legend-dot" style="background: var(--accent);"></div>
                                <span>Features</span>
                            </div>
                            <div class="timeline-legend-item">
                                <div class="timeline-legend-dot" style="background: var(--status-done);"></div>
                                <span>Commits</span>
                            </div>
                        </div>
                    </div>
                    <div class="timeline-container" id="timeline-content">
                        <div class="loading">Loading timeline</div>
                    </div>
                </div>

                <!-- Summary Section: Key Metrics & Health -->
                <div class="analytics-card analytics-card-wide" id="analytics-summary">
                    <h3>Summary & Health</h3>
                    <div class="analytics-summary" id="summary-content">
                        <div class="loading">Loading summary</div>
                    </div>
                </div>

                <!-- Collaboration Metrics -->
                <div class="analytics-card analytics-card-wide" id="analytics-collaboration">
                    <div class="collaboration-metrics">
                        <h3>Collaboration & Handoff Metrics</h3>
                        <div class="collaboration-grid" id="collaboration-content">
                            <div class="loading">Loading collaboration metrics</div>
                        </div>
                    </div>
                </div>

                <!-- Overview KPIs -->
                <div class="analytics-card" id="analytics-overview">
                    <h3>Overview</h3>
                    <div id="overview-kpis" class="loading">Loading overview</div>
                </div>

                <!-- Tool Patterns -->
                <div class="analytics-card" id="analytics-tools">
                    <div class="loading">Loading tool patterns</div>
                </div>

                <!-- Feature Analysis -->
                <div class="analytics-card" id="analytics-features">
                    <div class="loading">Loading top features</div>
                </div>

                <!-- Feature Continuity (hidden until feature selected) -->
                <div class="analytics-card analytics-card-wide" id="analytics-continuity" style="display: none;">
                    <div class="loading">Select a feature to see continuity</div>
                </div>

                <!-- Feature Commits (hidden until feature selected) -->
                <div class="analytics-card analytics-card-wide" id="analytics-commits" style="display: none;">
                    <div class="loading">Select a feature to see commits</div>
                </div>

                <!-- Commit DAG (hidden until feature selected) -->
                <div class="analytics-card analytics-card-wide" id="analytics-commit-dag" style="display: none;">
                    <div class="loading">Select a feature to see commit graph</div>
                </div>
            </div>
        </div>

        <!-- Sessions View -->
        <div class="sessions" id="sessions">
            <div class="analytics-header">
                <div>
                    <h2>Sessions</h2>
                    <p>View all Claude Code sessions tracked by HtmlGraph.</p>
                </div>
            </div>

            <!-- Session Filters -->
            <div class="session-filters">
                <div class="filter-group">
                    <label for="filter-status">Status:</label>
                    <select id="filter-status" class="filter-select">
                        <option value="">All</option>
                        <option value="active">Active</option>
                        <option value="ended">Ended</option>
                        <option value="stale">Stale</option>
                    </select>
                </div>

                <div class="filter-group">
                    <label for="filter-agent">Agent:</label>
                    <select id="filter-agent" class="filter-select">
                        <option value="">All</option>
                    </select>
                </div>

                <div class="filter-group">
                    <label for="filter-search">Search:</label>
                    <input type="text" id="filter-search" class="filter-input" placeholder="Session ID...">
                </div>

                <div class="filter-group">
                    <label for="filter-date-from">From:</label>
                    <input type="date" id="filter-date-from" class="filter-input">
                </div>

                <div class="filter-group">
                    <label for="filter-date-to">To:</label>
                    <input type="date" id="filter-date-to" class="filter-input">
                </div>

                <button id="filter-clear" class="btn btn-secondary" style="align-self: flex-end;">Clear</button>
                <button id="compare-sessions-btn" class="btn btn-primary" style="align-self: flex-end; display: none;">Compare Selected</button>
            </div>

            <div id="sessions-list" class="loading">Loading sessions...</div>
        </div>

        <!-- Agents View - Multi-Agent Work Attribution -->
        <div class="agents" id="agents">
            <div class="analytics-header">
                <div>
                    <h2>Multi-Agent Work Attribution</h2>
                    <p>Track which agents completed work items and monitor delegation performance.</p>
                </div>
                <div style="display:flex; gap:0.5rem; align-items:center;">
                    <button class="btn btn-primary" id="agents-refresh">Refresh</button>
                </div>
            </div>

            <!-- Agent Skills Matrix -->
            <div class="analytics-card analytics-card-wide" id="agent-skills-matrix">
                <h3>Agent Specializations & Skills Matrix</h3>
                <p style="color: var(--text-muted); font-size: 0.875rem; margin-bottom: 1.5rem;">
                    Proficiency levels based on work history analysis. Color intensity indicates expertise level (1=novice, 5=expert).
                </p>
                <div class="skills-matrix-container" id="skills-matrix-content">
                    <div class="loading">Analyzing agent work history...</div>
                </div>
            </div>

            <!-- Agent Stats Summary -->
            <div class="analytics-card" id="agent-summary">
                <div class="loading">Loading agent statistics...</div>
            </div>

            <!-- Workload Distribution Chart -->
            <div class="analytics-card analytics-card-wide">
                <div class="workload-chart-container" id="workload-chart">
                    <div class="workload-chart-header">
                        <h3>Agent Workload Distribution</h3>
                        <p>Horizontal bar chart showing work completion by agent</p>
                    </div>
                    <div id="workload-chart-content" class="loading">Loading workload data...</div>
                </div>
            </div>

            <!-- Agent Work Table -->
            <div class="analytics-card analytics-card-wide" id="agent-work-table">
                <div class="loading">Loading agent work data...</div>
            </div>

            <!-- Agent Performance Metrics -->
            <div class="analytics-card" id="agent-performance">
                <div class="loading">Loading agent performance metrics...</div>
            </div>

            <!-- Agent Cost Breakdown -->
            <div class="analytics-card analytics-card-wide" id="agent-costs">
                <div class="cost-breakdown-container">
                    <div class="cost-breakdown-header">
                        <h3>Agent Cost Breakdown</h3>
                        <p>Token costs aggregated by agent type with visual distribution</p>
                    </div>

                    <div class="cost-summary-metrics" id="cost-metrics">
                        <!-- Populated by JavaScript -->
                    </div>

                    <div class="cost-bars" id="cost-bars-container">
                        <!-- Populated by JavaScript -->
                    </div>

                    <div class="cost-breakdown-legend" id="cost-legend">
                        <!-- Populated by JavaScript -->
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- Detail Panel -->
    <div class="panel-overlay" id="panel-overlay"></div>
    <div class="panel" id="panel">
        <div class="panel-header">
            <h2 id="panel-title">Loading...</h2>
            <button class="panel-close" id="panel-close">&times;</button>
        </div>
        <div class="panel-body" id="panel-body">
            <div class="loading">Loading...</div>
        </div>
        <div class="panel-actions" id="panel-actions"></div>
    </div>

    <!-- Session Comparison Modal -->
    <div class="panel-overlay" id="comparison-overlay" style="display: none;"></div>
    <div class="panel" id="comparison-panel" style="display: none; width: 90%; max-width: 1400px;">
        <div class="panel-header">
            <h2>Session Comparison</h2>
            <button class="panel-close" id="comparison-close">&times;</button>
        </div>
        <div class="panel-body" id="comparison-body">
            <div class="loading">Loading comparison...</div>
        </div>
    </div>

    <script>
        // =====================================================================
        // Theme Toggle
        // =====================================================================

        const themeToggle = document.getElementById('theme-toggle');
        const themeIcon = themeToggle.querySelector('.theme-icon');

        function getTheme() {
            const stored = localStorage.getItem('theme');
            if (stored) return stored;
            return 'system';
        }

        function setTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            updateThemeIcon(theme);
        }

        function updateThemeIcon(theme) {
            const isDark = theme === 'dark' ||
                (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches);
            themeIcon.innerHTML = isDark ? '&#9790;' : '&#9788;';
        }

        themeToggle.addEventListener('click', () => {
            const current = getTheme();
            const next = current === 'light' ? 'dark' : current === 'dark' ? 'system' : 'light';
            setTheme(next);
        });

        // Initialize theme
        setTheme(getTheme());

        // Listen for system theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
            if (getTheme() === 'system') {
                updateThemeIcon('system');
            }
        });

        // =====================================================================
        // Constants
        // =====================================================================

        function resolveApiBase() {
            const params = new URLSearchParams(window.location.search);
            const apiParam = (params.get('api') || '').trim();
            const defaultOrigin = window.location.protocol === 'file:' ? 'http://localhost:8080' : window.location.origin;

            if (apiParam) {
                // Allow either absolute (http...) or absolute-path (/api) forms.
                if (apiParam.startsWith('/')) {
                    return new URL(apiParam, defaultOrigin).toString().replace(/\/$/, '');
                }
                return apiParam.replace(/\/$/, '');
            }

            return new URL('/api', defaultOrigin).toString().replace(/\/$/, '');
        }

        const API = resolveApiBase();
        const STATUSES = ['todo', 'in-progress', 'blocked', 'done'];
        const STATUS_LABELS = {
            'in-progress': 'In Progress',
            'todo': 'Todo',
            'blocked': 'Blocked',
            'done': 'Done'
        };

        let allNodes = [];
        let currentNode = null;
        let analyticsLoadedAt = 0;
        let analyticsCache = {
            overview: null,
            features: null,
            transitions: null,
            selectedFeatureId: null,
        };

        // =====================================================================
        // Data Loading
        // =====================================================================

        async function loadData() {
            console.log('[Dashboard] Loading data from:', API);
            const [status, query] = await Promise.all([
                fetch(`${API}/status`).then(r => r.json()),
                fetch(`${API}/query`).then(r => r.json())
            ]);
            allNodes = query.nodes;
            console.log('[Dashboard] Loaded nodes:', allNodes.length, 'Status:', status);
            return { status, nodes: query.nodes };
        }

        async function fetchJson(url) {
            const res = await fetch(url);
            const text = await res.text();
            let data = null;
            try { data = text ? JSON.parse(text) : null; } catch { /* ignore */ }
            if (!res.ok) {
                const msg = data && data.error ? data.error : `${res.status} ${res.statusText}`;
                throw new Error(msg);
            }
            return data;
        }

        async function fetchAnalytics(endpoint, params = {}) {
            const url = new URL(`${API}/analytics/${endpoint}`);
            Object.entries(params).forEach(([k, v]) => {
                if (v === undefined || v === null || v === '') return;
                url.searchParams.set(k, String(v));
            });
            return fetchJson(url.toString());
        }

        async function loadNode(collection, id) {
            const res = await fetch(`${API}/${collection}/${id}`);
            if (!res.ok) throw new Error('Node not found');
            return res.json();
        }

        async function updateNode(collection, id, data) {
            const res = await fetch(`${API}/${collection}/${id}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });
            if (!res.ok) throw new Error('Update failed');
            return res.json();
        }

        // =====================================================================
        // Rendering
        // =====================================================================

        function formatPercent(value) {
            if (value === null || value === undefined || Number.isNaN(value)) return '';
            return `${(value * 100).toFixed(1)}%`;
        }

        function formatFloat(value) {
            if (value === null || value === undefined || Number.isNaN(value)) return '';
            return Number(value).toFixed(2);
        }

        function renderTimeline(overview, features, transitions) {
            const el = document.getElementById('timeline-content');
            if (!overview) {
                el.innerHTML = '<p class="analytics-note">No timeline data available.</p>';
                return;
            }

            // Build timeline entries from overview data
            const entries = [];

            // Add overview entry (summary event)
            if (overview.events > 0) {
                entries.push({
                    type: 'session',
                    title: `${overview.events} events recorded`,
                    meta: `Failure rate: ${formatPercent(overview.failure_rate)}, Avg drift: ${formatFloat(overview.avg_drift)}`
                });
            }

            // Add top features as timeline entries
            if (features && features.length > 0) {
                features.slice(0, 5).forEach(f => {
                    entries.push({
                        type: 'feature',
                        title: f.feature_id,
                        meta: `${f.count} events, ${f.failures} failures`
                    });
                });
            }

            // Add top transitions as timeline entries
            if (transitions && transitions.length > 0) {
                transitions.slice(0, 3).forEach(t => {
                    entries.push({
                        type: 'session',
                        title: `${t.tool}  ${t.next_tool}`,
                        meta: `${t.count} transitions`
                    });
                });
            }

            if (entries.length === 0) {
                el.innerHTML = '<p class="analytics-note">No timeline events to display.</p>';
                return;
            }

            el.innerHTML = entries.map(e => `
                <div class="timeline-entry" title="${escapeHtml(e.meta)}">
                    <div class="timeline-entry-marker ${e.type}"></div>
                    <div class="timeline-entry-content">
                        <div class="timeline-entry-title">${escapeHtml(e.title)}</div>
                        <div class="timeline-entry-meta">${escapeHtml(e.meta)}</div>
                    </div>
                </div>
            `).join('');
        }

        function renderAnalyticsSummary(overview) {
            const el = document.getElementById('summary-content');
            if (!overview) {
                el.innerHTML = '<p class="analytics-note">No summary data available.</p>';
                return;
            }

            const failureRate = overview.failure_rate || 0;
            const avgDrift = overview.avg_drift || 0;
            const eventCount = overview.events || 0;

            // Determine health status
            const failureHealth = failureRate < 0.05 ? 'health-good' : failureRate < 0.15 ? 'health-ok' : 'health-poor';
            const driftHealth = avgDrift < 1.0 ? 'health-good' : avgDrift < 2.0 ? 'health-ok' : 'health-poor';
            const activityHealth = eventCount > 100 ? 'health-good' : eventCount > 20 ? 'health-ok' : 'health-poor';

            el.innerHTML = `
                <div class="health-card ${failureHealth}">
                    <div class="health-label">Failure Rate</div>
                    <div class="health-value">${formatPercent(failureRate)}</div>
                    <div class="health-detail">${failureRate < 0.05 ? ' Excellent' : failureRate < 0.15 ? ' Acceptable' : ' Needs attention'}</div>
                </div>
                <div class="health-card ${driftHealth}">
                    <div class="health-label">Avg Context Drift</div>
                    <div class="health-value">${formatFloat(avgDrift)}</div>
                    <div class="health-detail">${avgDrift < 1.0 ? ' Clean' : avgDrift < 2.0 ? ' Acceptable' : ' High drift'}</div>
                </div>
                <div class="health-card ${activityHealth}">
                    <div class="health-label">Total Events</div>
                    <div class="health-value">${eventCount}</div>
                    <div class="health-detail">${eventCount > 100 ? ' Active' : eventCount > 20 ? ' Some data' : ' Minimal activity'}</div>
                </div>
            `;
        }

        function renderCollaborationMetrics(overview) {
            const el = document.getElementById('collaboration-content');
            if (!overview) {
                el.innerHTML = '<p class="analytics-note">No collaboration data available.</p>';
                return;
            }

            // Extract or calculate collaboration metrics
            const handoffCount = overview.handoffs || 0;
            const parallelWorkPct = overview.parallel_work_pct || 0;
            const agentCount = overview.agent_count || 1;
            const avgSessionDuration = overview.avg_session_duration || 0;

            el.innerHTML = `
                <div class="collab-stat">
                    <div class="collab-stat-value">${handoffCount}</div>
                    <div class="collab-stat-label">Handoffs</div>
                </div>
                <div class="collab-stat">
                    <div class="collab-stat-value">${formatPercent(parallelWorkPct)}</div>
                    <div class="collab-stat-label">Parallel Work</div>
                </div>
                <div class="collab-stat">
                    <div class="collab-stat-value">${agentCount}</div>
                    <div class="collab-stat-label">Active Agents</div>
                </div>
                <div class="collab-stat">
                    <div class="collab-stat-value">${formatFloat(avgSessionDuration)}</div>
                    <div class="collab-stat-label">Avg Session (min)</div>
                </div>
            `;
        }

        function renderAnalyticsOverview(overview) {
            const el = document.getElementById('analytics-overview');
            el.innerHTML = `
                <h3>Overview</h3>
                <div class="analytics-kpis">
                    <div class="kpi">
                        <div class="kpi-value">${overview.events}</div>
                        <div class="kpi-label">Events</div>
                    </div>
                    <div class="kpi">
                        <div class="kpi-value">${formatPercent(overview.failure_rate)}</div>
                        <div class="kpi-label">Failure Rate</div>
                    </div>
                    <div class="kpi">
                        <div class="kpi-value">${formatFloat(overview.avg_drift)}</div>
                        <div class="kpi-label">Avg Drift</div>
                    </div>
                </div>
                <p class="analytics-note">If this is empty, run: <span class="mono">htmlgraph events export-sessions</span> then <span class="mono">htmlgraph index rebuild</span>.</p>
            `;
        }

        function renderAnalyticsTools(transitions) {
            const el = document.getElementById('analytics-tools');
            const rows = (transitions || []).map(t => `
                <tr>
                    <td>${t.tool}</td>
                    <td>${t.next_tool}</td>
                    <td>${t.count}</td>
                </tr>
            `).join('');

            el.innerHTML = `
                <h3>Top Tool Transitions</h3>
                <table class="table">
                    <thead>
                        <tr><th>Tool</th><th>Next</th><th>Count</th></tr>
                    </thead>
                    <tbody>
                        ${rows || `<tr><td colspan="3">No data.</td></tr>`}
                    </tbody>
                </table>
                <p class="analytics-note">Use this to spot repeated workflows worth automating (e.g. Grep  Read  Edit  Bash).</p>
            `;
        }

        function renderAnalyticsFeatures(features) {
            const el = document.getElementById('analytics-features');
            const rows = (features || []).map(f => `
                <tr>
                    <td><button class="feature-link" data-feature="${f.feature_id}">${f.feature_id}</button></td>
                    <td>${f.count}</td>
                    <td>${formatFloat(f.avg_drift)}</td>
                    <td>${f.failures}</td>
                </tr>
            `).join('');

            el.innerHTML = `
                <h3>Top Features</h3>
                <table class="table">
                    <thead>
                        <tr><th>Feature</th><th>Events</th><th>Avg Drift</th><th>Failures</th></tr>
                    </thead>
                    <tbody>
                        ${rows || `<tr><td colspan="4">No feature activity recorded.</td></tr>`}
                    </tbody>
                </table>
                <p class="analytics-note">Click a feature to see continuity across sessions.</p>
            `;
        }

        function renderAnalyticsContinuity(featureId, sessions) {
            const el = document.getElementById('analytics-continuity');
            const rows = (sessions || []).map(s => `
                <tr>
                    <td>${s.session_id}</td>
                    <td>${s.agent || ''}</td>
                    <td>${s.events}</td>
                    <td>${s.failures}</td>
                    <td>${formatFloat(s.avg_drift)}</td>
                    <td class="mono">${(s.first_ts || '').slice(0, 19)}</td>
                    <td class="mono">${(s.last_ts || '').slice(0, 19)}</td>
                </tr>
            `).join('');

            el.innerHTML = `
                <h3>Continuity: ${featureId}</h3>
                <table class="table">
                    <thead>
                        <tr>
                            <th>Session</th><th>Agent</th><th>Events</th><th>Fail</th><th>Avg Drift</th><th>First</th><th>Last</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${rows || `<tr><td colspan="7">No continuity data.</td></tr>`}
                    </tbody>
                </table>
                <p class="analytics-note">Continuity helps identify repeated context rebuild, drift, and same work across sessions.</p>
            `;
        }

        function renderAnalyticsCommits(featureId, commits) {
            const el = document.getElementById('analytics-commits');
            const rows = (commits || []).map(c => {
                const ts = (c.ts || '').slice(0, 19).replace('T', ' ');
                const short = c.commit_hash_short || (c.commit_hash || '').slice(0, 7);
                const branch = c.branch || '';
                const subj = c.subject || '';
                const delta = `${c.insertions || 0}+/${c.deletions || 0}-`;
                const parents = c.parent_count ?? 0;
                const merge = c.is_merge ? 'merge' : '';
                return `
                    <tr>
                        <td class="mono">${short}</td>
                        <td class="mono">${escapeHtml(branch)}</td>
                        <td>${escapeHtml(subj)}</td>
                        <td class="mono">${delta}</td>
                        <td class="mono">${parents}</td>
                        <td class="mono">${escapeHtml(ts)}</td>
                        <td class="mono">${merge}</td>
                    </tr>
                `;
            }).join('');

            el.innerHTML = `
                <h3>Commits: ${featureId}</h3>
                <p class="analytics-note">GitCommit events form the continuity spine. This view shows what actually advanced the feature across sessions/branches.</p>
                <table class="table">
                    <thead>
                        <tr>
                            <th>Commit</th><th>Branch</th><th>Subject</th><th></th><th>Parents</th><th>Time</th><th></th>
                        </tr>
                    </thead>
                    <tbody>
                        ${rows || `<tr><td colspan="7">No commit data for this feature yet.</td></tr>`}
                    </tbody>
                </table>
            `;
        }

        // =====================================================================
        // Commit DAG Visualization
        // =====================================================================
        let commitDagSimulation = null;

        function renderCommitDag(featureId, graph) {
            const el = document.getElementById('analytics-commit-dag');
            const nodes = graph?.nodes || [];
            const edges = graph?.edges || [];

            if (nodes.length === 0) {
                el.innerHTML = `
                    <h3>Commit Graph: ${featureId}</h3>
                    <p class="analytics-note">No commits found for this feature yet. Make commits with this feature active to populate the graph.</p>
                `;
                return;
            }

            // Build the visualization HTML
            el.innerHTML = `
                <h3>Commit Graph: ${featureId}</h3>
                <p class="analytics-note">DAG visualization of commits advancing this feature. Larger nodes = more changes. Hover for details.</p>
                <div class="commit-dag-container">
                    <svg class="commit-dag-svg" id="commit-dag-svg">
                        <defs>
                            <marker id="commit-arrowhead" viewBox="0 0 10 10" refX="25" refY="5"
                                markerWidth="4" markerHeight="4" orient="auto-start-reverse">
                                <path d="M 0 0 L 10 5 L 0 10 z" fill="var(--text-muted)" />
                            </marker>
                        </defs>
                        <g class="edges-group"></g>
                        <g class="nodes-group"></g>
                    </svg>
                </div>
                <div class="commit-dag-legend">
                    <div class="commit-dag-legend-item">
                        <div class="dot large"></div>
                        <span>Many changes</span>
                    </div>
                    <div class="commit-dag-legend-item">
                        <div class="dot small"></div>
                        <span>Few changes</span>
                    </div>
                    <div class="commit-dag-legend-item">
                        <div class="dot external"></div>
                        <span>Parent (external)</span>
                    </div>
                </div>
            `;

            // Now render the DAG with d3-force
            const svg = document.getElementById('commit-dag-svg');
            const edgesGroup = svg.querySelector('.edges-group');
            const nodesGroup = svg.querySelector('.nodes-group');
            const rect = svg.getBoundingClientRect();
            const width = rect.width || 800;
            const height = rect.height || 400;

            // Create node map for quick lookup
            const nodeById = new Map();
            const graphNodes = nodes.map((n, i) => {
                const node = {
                    id: n.id,
                    hash: n.commit_hash_short || n.id.slice(0, 7),
                    subject: n.subject || '',
                    branch: n.branch || '',
                    ts: n.ts || '',
                    isMerge: n.is_merge || false,
                    external: n.external || false,
                    insertions: n.insertions || 0,
                    deletions: n.deletions || 0,
                    x: width * 0.1 + (i * width * 0.8 / Math.max(1, nodes.length - 1)),
                    y: height / 2
                };
                nodeById.set(node.id, node);
                return node;
            });

            // Build edges with source/target references
            const graphEdges = edges.map(e => ({
                source: e.from,
                target: e.to
            })).filter(e => nodeById.has(e.source) && nodeById.has(e.target));

            // Calculate node radius based on changes
            function getCommitRadius(node) {
                if (node.external) return 12;
                const changes = (node.insertions || 0) + (node.deletions || 0);
                return Math.max(15, Math.min(35, 15 + Math.sqrt(changes) * 0.5));
            }

            // Get node color
            function getCommitColor(node) {
                if (node.external) return 'var(--bg-tertiary)';
                if (node.isMerge) return 'var(--priority-medium)';
                return 'var(--status-active)';
            }

            // Stop any previous simulation
            if (commitDagSimulation) commitDagSimulation.stop();

            // Create force simulation
            commitDagSimulation = d3.forceSimulation(graphNodes)
                .force('link', d3.forceLink(graphEdges)
                    .id(d => d.id)
                    .distance(80)
                    .strength(0.8))
                .force('charge', d3.forceManyBody()
                    .strength(-200))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => getCommitRadius(d) + 10))
                .force('x', d3.forceX(width / 2).strength(0.05))
                .force('y', d3.forceY(height / 2).strength(0.1))
                .on('tick', updateDagPositions);

            // Render edges
            graphEdges.forEach(edge => {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                line.classList.add('commit-edge');
                line.setAttribute('marker-end', 'url(#commit-arrowhead)');
                line.dataset.source = typeof edge.source === 'object' ? edge.source.id : edge.source;
                line.dataset.target = typeof edge.target === 'object' ? edge.target.id : edge.target;
                edgesGroup.appendChild(line);
            });

            // Render nodes
            graphNodes.forEach(node => {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.classList.add('commit-node');
                if (node.isMerge) g.classList.add('merge');
                if (node.external) g.classList.add('external');
                g.dataset.id = node.id;

                const radius = getCommitRadius(node);
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('r', radius);
                circle.setAttribute('fill', getCommitColor(node));

                // Add hash label inside node
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.textContent = node.hash;

                g.appendChild(circle);
                g.appendChild(text);

                // Add subject label below node
                if (node.subject && !node.external) {
                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.classList.add('commit-label');
                    label.setAttribute('dy', radius + 12);
                    label.setAttribute('text-anchor', 'middle');
                    const truncated = node.subject.length > 30 ? node.subject.slice(0, 27) + '...' : node.subject;
                    label.textContent = truncated;
                    g.appendChild(label);
                }

                // Add branch label above node
                if (node.branch && !node.external) {
                    const branchLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    branchLabel.classList.add('branch-label');
                    branchLabel.setAttribute('dy', -(radius + 8));
                    branchLabel.setAttribute('text-anchor', 'middle');
                    branchLabel.textContent = node.branch;
                    g.appendChild(branchLabel);
                }

                nodesGroup.appendChild(g);

                // Add tooltip on hover
                g.addEventListener('mouseenter', (e) => {
                    const tooltip = `${node.hash}
${node.branch || 'no branch'}
${node.subject || 'external parent'}
+${node.insertions}/-${node.deletions}
${node.ts ? node.ts.slice(0, 19).replace('T', ' ') : ''}`;
                    g.setAttribute('title', tooltip);
                });

                // Make nodes draggable
                let isDragging = false;
                let dragOffset = { x: 0, y: 0 };

                g.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    const svgRect = svg.getBoundingClientRect();
                    dragOffset = {
                        x: e.clientX - svgRect.left - node.x,
                        y: e.clientY - svgRect.top - node.y
                    };
                    commitDagSimulation.alphaTarget(0.3).restart();
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const svgRect = svg.getBoundingClientRect();
                        node.fx = e.clientX - svgRect.left - dragOffset.x;
                        node.fy = e.clientY - svgRect.top - dragOffset.y;
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        node.fx = null;
                        node.fy = null;
                        commitDagSimulation.alphaTarget(0);
                    }
                });
            });

            function updateDagPositions() {
                // Update node positions
                nodesGroup.querySelectorAll('.commit-node').forEach(g => {
                    const node = nodeById.get(g.dataset.id);
                    if (node) {
                        node.x = Math.max(40, Math.min(width - 40, node.x));
                        node.y = Math.max(40, Math.min(height - 40, node.y));
                        g.setAttribute('transform', `translate(${node.x}, ${node.y})`);
                    }
                });

                // Update edge paths (curved for visual appeal)
                edgesGroup.querySelectorAll('.commit-edge').forEach(path => {
                    const source = nodeById.get(path.dataset.source);
                    const target = nodeById.get(path.dataset.target);
                    if (source && target) {
                        const dx = target.x - source.x;
                        const dy = target.y - source.y;
                        const dr = Math.sqrt(dx * dx + dy * dy) * 0.5;
                        path.setAttribute('d', `M${source.x},${source.y} Q${(source.x + target.x) / 2},${(source.y + target.y) / 2 - dr * 0.3} ${target.x},${target.y}`);
                    }
                });
            }
        }

        async function loadAndRenderCommitDag(featureId) {
            const data = await fetchAnalytics('commit-graph', { feature_id: featureId });
            renderCommitDag(featureId, data.graph || {});
        }

        function renderAnalyticsError(err) {
            const msg = err && err.message ? err.message : String(err);
            const overview = document.getElementById('analytics-overview');
            const tools = document.getElementById('analytics-tools');
            const features = document.getElementById('analytics-features');
            const continuity = document.getElementById('analytics-continuity');
            const commits = document.getElementById('analytics-commits');
            const commitDag = document.getElementById('analytics-commit-dag');
            const hint = window.location.protocol === 'file:'
                ? 'You opened this dashboard as a local file. Run <span class="mono">htmlgraph serve</span> and open <span class="mono">http://localhost:8080</span>, or pass <span class="mono">?api=http://localhost:8080/api</span>.'
                : 'Ensure <span class="mono">htmlgraph serve</span> is running and accessible from this page.';

            const html = `
                <h3>Analytics Unavailable</h3>
                <p class="analytics-note">${msg}</p>
                <p class="analytics-note">${hint}</p>
                <p class="analytics-note">Build the index:</p>
                <pre class="mono">PYTHONPATH=src/python .venv/bin/python -m htmlgraph.cli events export-sessions -g .htmlgraph\nPYTHONPATH=src/python .venv/bin/python -m htmlgraph.cli index rebuild -g .htmlgraph</pre>
            `;
            overview.innerHTML = html;
            tools.innerHTML = html;
            features.innerHTML = html;
            continuity.innerHTML = html;
            commits.innerHTML = html;
            if (commitDag) commitDag.innerHTML = html;
        }

        async function loadAndRenderAnalyticsBase() {
            console.log('[Dashboard] Loading analytics from:', `${API}/analytics/`);
            const [overview, features, transitions] = await Promise.all([
                fetchAnalytics('overview').catch(e => { console.error('[Analytics] overview failed:', e); return null; }),
                fetchAnalytics('features', { limit: 50 }).then(r => r.features).catch(e => { console.error('[Analytics] features failed:', e); return null; }),
                fetchAnalytics('transitions', { limit: 25 }).then(r => r.transitions).catch(e => { console.error('[Analytics] transitions failed:', e); return null; }),
            ]);

            analyticsCache.overview = overview;
            analyticsCache.features = features;
            analyticsCache.transitions = transitions;
            analyticsLoadedAt = Date.now();
            console.log('[Analytics] Loaded - overview:', !!overview, 'features:', features?.length || 0, 'transitions:', transitions?.length || 0);

            // Render primary analytics views (new card-based layout)
            renderTimeline(overview, features, transitions);
            renderAnalyticsSummary(overview);
            renderCollaborationMetrics(overview);

            // Render detail cards
            renderAnalyticsOverview(overview);
            renderAnalyticsTools(transitions);
            renderAnalyticsFeatures(features);
        }

        async function loadAndRenderContinuity(featureId) {
            analyticsCache.selectedFeatureId = featureId;
            const data = await fetchAnalytics('continuity', { feature_id: featureId, limit: 200 });
            renderAnalyticsContinuity(featureId, data.sessions || []);
        }

        async function loadAndRenderCommits(featureId) {
            const data = await fetchAnalytics('commits', { feature_id: featureId, limit: 200 });
            renderAnalyticsCommits(featureId, data.commits || []);
        }

        async function loadFeatureAnalytics(featureId) {
            analyticsCache.selectedFeatureId = featureId;

            // Show the detail sections for selected feature
            document.getElementById('analytics-continuity').style.display = 'block';
            document.getElementById('analytics-commits').style.display = 'block';
            document.getElementById('analytics-commit-dag').style.display = 'block';

            await Promise.all([
                loadAndRenderContinuity(featureId),
                loadAndRenderCommits(featureId),
                loadAndRenderCommitDag(featureId)
            ]);
        }

        // =====================================================================
        // Agent Cost Visualization
        // =====================================================================

        const AGENT_COLORS = {
            'claude': '#2979FF',
            'codex': '#00C853',
            'orchestrator': '#7C4DFF',
            'gemini': '#FBC02D',
            'gemini-2': '#FF9100',
            'analyst': '#0ea5e9',
            'developer': '#06b6d4',
            'researcher': '#d946ef',
            'debugger': '#ef4444',
            'default': '#78909C'
        };

        function getAgentColor(agent) {
            const normalized = (agent || 'default').toLowerCase();
            return AGENT_COLORS[normalized] || AGENT_COLORS['default'];
        }

        function formatCost(tokens) {
            // Approximate cost: $0.003 per 1K input tokens
            const cost = (tokens / 1000) * 0.003;
            return cost.toFixed(4);
        }

        function formatCostDisplay(tokens) {
            const cost = parseFloat(formatCost(tokens));
            if (cost === 0) return '$0.00';
            return `$${cost.toFixed(2)}`;
        }

        function getCostRange(cost) {
            // Define ranges: low (< $0.01), medium ($0.01-$0.05), high (> $0.05)
            const numCost = parseFloat(formatCost(cost));
            if (numCost < 0.01) return 'low';
            if (numCost < 0.05) return 'medium';
            return 'high';
        }

        function aggregateAgentCosts(sessions) {
            const costsByAgent = {};
            let totalCost = 0;

            sessions.forEach(session => {
                const agent = session.properties?.agent || 'unknown';
                const tokens = parseInt(session.properties?.total_tokens) || 0;

                if (!costsByAgent[agent]) {
                    costsByAgent[agent] = {
                        agent,
                        totalTokens: 0,
                        operationCount: 0,
                        sessionCount: 0
                    };
                }

                costsByAgent[agent].totalTokens += tokens;
                costsByAgent[agent].operationCount += parseInt(session.properties?.event_count) || 0;
                costsByAgent[agent].sessionCount += 1;
                totalCost += tokens;
            });

            return {
                byAgent: Object.values(costsByAgent).sort((a, b) => b.totalTokens - a.totalTokens),
                totalTokens: totalCost
            };
        }

        function renderAgentCostMetrics(costs) {
            const metricsEl = document.getElementById('cost-metrics');
            if (!metricsEl || costs.byAgent.length === 0) return;

            const avgCostPerAgent = costs.totalTokens / costs.byAgent.length;
            const totalCostUSD = formatCostDisplay(costs.totalTokens);
            const avgCostUSD = formatCostDisplay(avgCostPerAgent);

            const topAgent = costs.byAgent[0];
            const topAgentPercent = ((topAgent.totalTokens / costs.totalTokens) * 100).toFixed(1);

            metricsEl.innerHTML = `
                <div class="cost-metric">
                    <div class="cost-metric-label">Total Cost</div>
                    <div class="cost-metric-value">${totalCostUSD}</div>
                    <div class="cost-metric-unit">${costs.totalTokens.toLocaleString()} tokens</div>
                </div>
                <div class="cost-metric">
                    <div class="cost-metric-label">Average Per Agent</div>
                    <div class="cost-metric-value">${avgCostUSD}</div>
                    <div class="cost-metric-unit">~${Math.round(avgCostPerAgent).toLocaleString()} tokens</div>
                </div>
                <div class="cost-metric">
                    <div class="cost-metric-label">Top Agent</div>
                    <div class="cost-metric-value">${topAgent.agent}</div>
                    <div class="cost-metric-unit">${topAgentPercent}% of total</div>
                </div>
                <div class="cost-metric">
                    <div class="cost-metric-label">Agent Count</div>
                    <div class="cost-metric-value">${costs.byAgent.length}</div>
                    <div class="cost-metric-unit">unique agents</div>
                </div>
            `;
        }

        function renderAgentCostBars(costs) {
            const containerEl = document.getElementById('cost-bars-container');
            if (!containerEl || costs.byAgent.length === 0) {
                if (containerEl) containerEl.innerHTML = '<div class="loading">No cost data available</div>';
                return;
            }

            const maxCost = Math.max(...costs.byAgent.map(a => a.totalTokens));

            const barsHTML = costs.byAgent.map(agent => {
                const percentOfTotal = (agent.totalTokens / costs.totalTokens) * 100;
                const costUSD = formatCostDisplay(agent.totalTokens);
                const costRange = getCostRange(agent.totalTokens);
                const color = getAgentColor(agent.agent);
                const avgPerSession = Math.round(agent.totalTokens / agent.sessionCount);

                return `
                    <div class="cost-bar-group">
                        <div class="cost-bar-label">
                            <div class="cost-bar-label-name">
                                <div class="cost-agent-badge" style="background: ${color};">
                                    ${agent.agent.substring(0, 1).toUpperCase()}
                                </div>
                                <span>${agent.agent}</span>
                            </div>
                            <div class="cost-bar-stats">
                                <div class="cost-bar-stat">
                                    <div class="cost-bar-stat-label">Cost</div>
                                    <div class="cost-bar-stat-value">${costUSD}</div>
                                </div>
                                <div class="cost-bar-stat">
                                    <div class="cost-bar-stat-label">%</div>
                                    <div class="cost-bar-stat-value">${percentOfTotal.toFixed(1)}%</div>
                                </div>
                                <div class="cost-bar-stat">
                                    <div class="cost-bar-stat-label">Tokens</div>
                                    <div class="cost-bar-stat-value">${agent.totalTokens.toLocaleString()}</div>
                                </div>
                            </div>
                        </div>

                        <div class="cost-bar-container">
                            <div class="cost-bar-stacked">
                                <div class="cost-bar-segment" style="
                                    width: 100%;
                                    background: ${color};
                                    opacity: 0.85;
                                " title="${agent.agent}: ${costUSD}">
                                    <span class="cost-bar-segment-label">
                                        ${percentOfTotal.toFixed(0)}%
                                    </span>
                                </div>
                            </div>
                            <div class="cost-bar-tooltip">
                                Sessions: ${agent.sessionCount} | Avg/Session: ${avgPerSession.toLocaleString()} tokens
                            </div>
                        </div>

                        <div class="cost-range-indicator">
                            <div class="cost-range-dot ${costRange}"></div>
                            <span>${costRange === 'low' ? 'Low' : costRange === 'medium' ? 'Medium' : 'High'} cost</span>
                        </div>
                    </div>
                `;
            }).join('');

            containerEl.innerHTML = barsHTML;
        }

        function renderAgentCostLegend(costs) {
            const legendEl = document.getElementById('cost-legend');
            if (!legendEl || costs.byAgent.length === 0) return;

            const legendItems = costs.byAgent.map(agent => {
                const color = getAgentColor(agent.agent);
                return `
                    <div class="cost-legend-item">
                        <div class="cost-legend-color" style="background: ${color};"></div>
                        <span class="cost-legend-label">${agent.agent}</span>
                    </div>
                `;
            }).join('');

            legendEl.innerHTML = legendItems;
        }

        async function loadAndRenderAgentCosts() {
            const container = document.getElementById('agent-costs');
            if (!container) return;

            try {
                // Fetch all sessions to aggregate costs
                if (allSessions.length === 0) {
                    const response = await fetch(`${API}/sessions`);
                    if (!response.ok) throw new Error('Failed to load sessions');
                    const data = await response.json();
                    allSessions = data.nodes || [];
                }

                if (allSessions.length === 0) {
                    return;
                }

                // Aggregate costs by agent
                const costs = aggregateAgentCosts(allSessions);

                // Render visualization
                renderAgentCostMetrics(costs);
                renderAgentCostBars(costs);
                renderAgentCostLegend(costs);
            } catch (err) {
                console.error('Error loading agent costs:', err);
            }
        }

        async function ensureAnalyticsLoaded(force = false) {
            const stale = (Date.now() - analyticsLoadedAt) > 60_000;
            if (!force && analyticsCache.overview && !stale) return;
            try {
                await loadAndRenderAnalyticsBase();
                await loadAndRenderAgentCosts();
                if (!analyticsCache.selectedFeatureId && analyticsCache.features && analyticsCache.features.length) {
                    await loadFeatureAnalytics(analyticsCache.features[0].feature_id);
                }
            } catch (err) {
                renderAnalyticsError(err);
            }
        }

        let allSessions = []; // Cache for filtering

        async function loadAndRenderSessions(filters = {}) {
            const sessionsListEl = document.getElementById('sessions-list');

            try {
                // Fetch all sessions from the API (only on first load)
                if (allSessions.length === 0) {
                    console.log('[Sessions] Fetching from:', `${API}/sessions`);
                    const response = await fetch(`${API}/sessions`);
                    if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);

                    const data = await response.json();
                    allSessions = data.nodes || [];
                    console.log('[Sessions] Loaded', allSessions.length, 'sessions from API response keys:', Object.keys(data));

                    // Populate agent dropdown with unique agents
                    const agents = [...new Set(allSessions.map(s => s.properties?.agent).filter(Boolean))];
                    const agentSelect = document.getElementById('filter-agent');
                    agents.forEach(agent => {
                        const option = document.createElement('option');
                        option.value = agent;
                        option.textContent = agent;
                        agentSelect.appendChild(option);
                    });
                }

                if (allSessions.length === 0) {
                    sessionsListEl.innerHTML = '<div class="loading">No sessions found.</div>';
                    return;
                }

                // Apply filters
                let filteredSessions = allSessions.filter(s => {
                    // Status filter
                    if (filters.status && s.status !== filters.status) return false;

                    // Agent filter
                    if (filters.agent && s.properties?.agent !== filters.agent) return false;

                    // Search filter
                    if (filters.search && !s.id.toLowerCase().includes(filters.search.toLowerCase())) return false;

                    // Date range filter
                    const sessionDate = new Date(s.created);
                    if (filters.dateFrom) {
                        const fromDate = new Date(filters.dateFrom);
                        if (sessionDate < fromDate) return false;
                    }
                    if (filters.dateTo) {
                        const toDate = new Date(filters.dateTo);
                        toDate.setHours(23, 59, 59, 999); // End of day
                        if (sessionDate > toDate) return false;
                    }

                    return true;
                });

                // Sort by updated descending (most recent first)
                filteredSessions.sort((a, b) => new Date(b.updated) - new Date(a.updated));

                if (filteredSessions.length === 0) {
                    sessionsListEl.innerHTML = '<div class="loading">No sessions match the current filters.</div>';
                    return;
                }

                // Render sessions table
                const rows = filteredSessions.map(s => {
                    const created = new Date(s.created).toLocaleString();
                    const updated = new Date(s.updated).toLocaleString();
                    const statusBadge = s.status === 'active' ? 'status-active' : 'status-done';
                    const hasTranscript = s.properties?.transcript_id ? true : false;
                    const transcriptIcon = hasTranscript ? '<span title="Transcript linked" style="cursor: help;"></span>' : '<span style="color: var(--text-muted);"></span>';

                    return `
                        <tr>
                            <td style="width: 40px; text-align: center;">
                                <input type="checkbox" class="session-compare-checkbox" data-session-id="${s.id}" />
                            </td>
                            <td>
                                <span class="session-id" data-collection="sessions" data-id="${s.id}">
                                    ${s.id}
                                </span>
                            </td>
                            <td><span class="badge ${statusBadge}">${s.status}</span></td>
                            <td>${s.properties?.event_count || 0}</td>
                            <td style="text-align: center;">${transcriptIcon}</td>
                            <td>${s.properties?.agent || ''}</td>
                            <td class="mono">${created}</td>
                            <td class="mono">${updated}</td>
                        </tr>
                    `;
                }).join('');

                sessionsListEl.innerHTML = `
                    <table class="sessions-table">
                        <thead>
                            <tr>
                                <th style="width: 40px;"></th>
                                <th>Session ID</th>
                                <th>Status</th>
                                <th>Events</th>
                                <th title="Claude Code Transcript">Tx</th>
                                <th>Agent</th>
                                <th>Created</th>
                                <th>Updated</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${rows}
                        </tbody>
                    </table>
                    <div style="margin-top: 1rem; text-align: center; color: var(--text-muted); font-size: 0.875rem;">
                        Showing ${filteredSessions.length} of ${allSessions.length} sessions
                    </div>
                `;

                // Add click handlers for session IDs
                sessionsListEl.querySelectorAll('.session-id').forEach(link => {
                    link.addEventListener('click', () => {
                        openPanel(link.dataset.collection, link.dataset.id);
                    });
                });

                // Add checkbox handlers for comparison
                sessionsListEl.querySelectorAll('.session-compare-checkbox').forEach(checkbox => {
                    checkbox.addEventListener('change', updateCompareButton);
                });

            } catch (err) {
                sessionsListEl.innerHTML = `<div class="loading">Error loading sessions: ${err.message}</div>`;
            }
        }

        function updateCompareButton() {
            const selectedCheckboxes = document.querySelectorAll('.session-compare-checkbox:checked');
            const compareBtn = document.getElementById('compare-sessions-btn');

            if (selectedCheckboxes.length >= 2) {
                compareBtn.style.display = 'block';
                compareBtn.textContent = `Compare ${selectedCheckboxes.length} Sessions`;
            } else {
                compareBtn.style.display = 'none';
            }
        }

        async function compareSessions() {
            console.log('=== compareSessions called ===');
            const selectedCheckboxes = document.querySelectorAll('.session-compare-checkbox:checked');
            const sessionIds = Array.from(selectedCheckboxes).map(cb => cb.dataset.sessionId);
            console.log('Selected session IDs:', sessionIds);

            if (sessionIds.length < 2) {
                alert('Please select at least 2 sessions to compare');
                return;
            }

            const comparisonOverlay = document.getElementById('comparison-overlay');
            const comparisonPanel = document.getElementById('comparison-panel');
            const comparisonBody = document.getElementById('comparison-body');

            console.log('Modal elements found:', {
                overlay: !!comparisonOverlay,
                panel: !!comparisonPanel,
                body: !!comparisonBody
            });

            console.log('Setting display to block and adding open class...');
            comparisonOverlay.style.display = 'block';
            comparisonPanel.style.display = 'block';
            comparisonOverlay.classList.add('open');
            comparisonPanel.classList.add('open');
            comparisonBody.innerHTML = '<div class="loading">Loading session data...</div>';

            console.log('Modal styles after setting:', {
                overlayDisplay: window.getComputedStyle(comparisonOverlay).display,
                overlayZIndex: window.getComputedStyle(comparisonOverlay).zIndex,
                panelDisplay: window.getComputedStyle(comparisonPanel).display,
                panelZIndex: window.getComputedStyle(comparisonPanel).zIndex,
                panelPosition: window.getComputedStyle(comparisonPanel).position
            });

            try {
                // Fetch all selected sessions
                const sessionPromises = sessionIds.map(id =>
                    fetch(`${API}/sessions/${id}`).then(r => r.json())
                );
                const sessions = await Promise.all(sessionPromises);

                // Build comparison table
                let html = '<div style="overflow-x: auto;"><table class="comparison-table" style="width: 100%; border-collapse: collapse;">';

                // Header row with session IDs
                html += '<thead><tr><th style="text-align: left; padding: 1rem; border-bottom: 2px solid var(--border-strong); background: var(--bg-tertiary);">Metric</th>';
                sessions.forEach(s => {
                    html += `<th style="text-align: center; padding: 1rem; border-bottom: 2px solid var(--border-strong); background: var(--bg-tertiary);"><div style="font-family: monospace; font-size: 0.75rem;">${s.id}</div></th>`;
                });
                html += '</tr></thead><tbody>';

                // Status row
                html += '<tr><td style="padding: 0.75rem; border-bottom: 1px solid var(--border); font-weight: 600;">Status</td>';
                sessions.forEach(s => {
                    const badge = s.status === 'active' ? 'status-active' : 'status-done';
                    html += `<td style="padding: 0.75rem; border-bottom: 1px solid var(--border); text-align: center;"><span class="badge ${badge}">${s.status}</span></td>`;
                });
                html += '</tr>';

                // Event count row
                html += '<tr><td style="padding: 0.75rem; border-bottom: 1px solid var(--border); font-weight: 600;">Events</td>';
                sessions.forEach(s => {
                    html += `<td style="padding: 0.75rem; border-bottom: 1px solid var(--border); text-align: center;">${s.properties?.event_count || 0}</td>`;
                });
                html += '</tr>';

                // Agent row
                html += '<tr><td style="padding: 0.75rem; border-bottom: 1px solid var(--border); font-weight: 600;">Agent</td>';
                sessions.forEach(s => {
                    html += `<td style="padding: 0.75rem; border-bottom: 1px solid var(--border); text-align: center;">${s.properties?.agent || ''}</td>`;
                });
                html += '</tr>';

                // Created row
                html += '<tr><td style="padding: 0.75rem; border-bottom: 1px solid var(--border); font-weight: 600;">Created</td>';
                sessions.forEach(s => {
                    html += `<td style="padding: 0.75rem; border-bottom: 1px solid var(--border); text-align: center; font-family: monospace; font-size: 0.75rem;">${new Date(s.created).toLocaleString()}</td>`;
                });
                html += '</tr>';

                // Last activity row
                html += '<tr><td style="padding: 0.75rem; border-bottom: 1px solid var(--border); font-weight: 600;">Last Activity</td>';
                sessions.forEach(s => {
                    html += `<td style="padding: 0.75rem; border-bottom: 1px solid var(--border); text-align: center; font-family: monospace; font-size: 0.75rem;">${new Date(s.updated).toLocaleString()}</td>`;
                });
                html += '</tr>';

                // Duration row
                html += '<tr><td style="padding: 0.75rem; border-bottom: 1px solid var(--border); font-weight: 600;">Duration</td>';
                sessions.forEach(s => {
                    const duration = Math.round((new Date(s.updated) - new Date(s.created)) / 60000); // minutes
                    const hours = Math.floor(duration / 60);
                    const minutes = duration % 60;
                    const durationStr = hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;
                    html += `<td style="padding: 0.75rem; border-bottom: 1px solid var(--border); text-align: center;">${durationStr}</td>`;
                });
                html += '</tr>';

                html += '</tbody></table></div>';

                comparisonBody.innerHTML = html;
                console.log(' Comparison modal content loaded successfully');

            } catch (err) {
                console.error(' Error in compareSessions:', err);
                comparisonBody.innerHTML = `<div class="loading">Error loading sessions: ${err.message}</div>`;
            }
        }

        function closeComparison() {
            const overlay = document.getElementById('comparison-overlay');
            const panel = document.getElementById('comparison-panel');
            overlay.classList.remove('open');
            panel.classList.remove('open');
            // Give time for transition before hiding
            setTimeout(() => {
                overlay.style.display = 'none';
                panel.style.display = 'none';
            }, 300);
        }

        function applySessionFilters() {
            const filters = {
                status: document.getElementById('filter-status').value,
                agent: document.getElementById('filter-agent').value,
                search: document.getElementById('filter-search').value,
                dateFrom: document.getElementById('filter-date-from').value,
                dateTo: document.getElementById('filter-date-to').value
            };
            loadAndRenderSessions(filters);
        }

        function clearSessionFilters() {
            document.getElementById('filter-status').value = '';
            document.getElementById('filter-agent').value = '';
            document.getElementById('filter-search').value = '';
            document.getElementById('filter-date-from').value = '';
            document.getElementById('filter-date-to').value = '';
            loadAndRenderSessions();
        }

        // =====================================================================
        // Tracks View
        // =====================================================================

        async function loadAndRenderTracks() {
            const tracksListEl = document.getElementById('tracks-list');

            try {
                // Fetch all tracks from the API
                const response = await fetch(`${API}/tracks`);
                if (!response.ok) throw new Error('Failed to load tracks');

                const data = await response.json();
                const tracks = data.nodes || [];

                if (tracks.length === 0) {
                    tracksListEl.innerHTML = '<div class="loading">No tracks found.</div>';
                    return;
                }

                // Fetch all features to group by track
                const featuresResponse = await fetch(`${API}/query?type=feature`);
                const featuresData = await featuresResponse.json();
                const allFeatures = featuresData.nodes || [];

                // Group features by track_id
                const featuresByTrack = {};
                allFeatures.forEach(feature => {
                    const trackId = feature.track_id || 'untracked';
                    if (!featuresByTrack[trackId]) {
                        featuresByTrack[trackId] = [];
                    }
                    featuresByTrack[trackId].push(feature);
                });

                // Prepare track data in the same format as FEATURES view
                const tracksWithMetadata = tracks.map(track => ({
                    track: track,
                    features: featuresByTrack[track.id] || []
                }));

                // Sort by priority (critical > high > medium > low)
                const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
                tracksWithMetadata.sort((a, b) => priorityOrder[a.track.priority] - priorityOrder[b.track.priority]);

                // Remove loading class to eliminate padding
                tracksListEl.className = '';

                // Use the shared renderTrackSections function (same as FEATURES view)
                tracksListEl.innerHTML = `
                    <div class="track-sections-container">
                        ${tracksWithMetadata.map((trackData, idx) => renderTrackSection(trackData, idx === 0)).join('')}
                    </div>
                    <div style="margin-top: 1rem; text-align: center; color: var(--text-muted); font-size: 0.875rem;">
                        ${tracks.length} track${tracks.length !== 1 ? 's' : ''} found
                    </div>
                `;

                // Add event listeners using the shared function (same as FEATURES view)
                attachTrackEventListeners('#tracks-list');

            } catch (err) {
                tracksListEl.innerHTML = `<div class="loading">Error loading tracks: ${err.message}</div>`;
            }
        }

        // Get collapsed columns from localStorage
        function getCollapsedColumns() {
            try {
                return JSON.parse(localStorage.getItem('collapsedColumns') || '[]');
            } catch { return []; }
        }

        function setCollapsedColumns(cols) {
            localStorage.setItem('collapsedColumns', JSON.stringify(cols));
        }

        function updateKanbanGrid() {
            const kanban = document.getElementById('kanban');
            const collapsed = getCollapsedColumns();

            if (collapsed.length > 0) {
                kanban.classList.add('has-collapsed');

                // If ALL columns are collapsed, center them (keep narrow)
                if (collapsed.length === STATUSES.length) {
                    kanban.classList.add('all-collapsed');
                    kanban.style.setProperty('--kanban-grid', 'repeat(4, 52px)');
                } else {
                    kanban.classList.remove('all-collapsed');
                    // Build dynamic grid: 1fr for expanded, 52px for collapsed
                    const gridCols = STATUSES.map(s =>
                        collapsed.includes(s) ? '52px' : '1fr'
                    ).join(' ');
                    kanban.style.setProperty('--kanban-grid', gridCols);
                }
            } else {
                kanban.classList.remove('has-collapsed');
                kanban.classList.remove('all-collapsed');
                kanban.style.removeProperty('--kanban-grid');
            }
        }

        function toggleColumnCollapse(status) {
            const collapsed = getCollapsedColumns();
            const idx = collapsed.indexOf(status);
            if (idx > -1) {
                // Expanding a column
                collapsed.splice(idx, 1);
            } else {
                // Collapsing a column
                collapsed.push(status);

                // If all columns would be collapsed, auto-open In Progress
                if (collapsed.length === STATUSES.length) {
                    const ipIdx = collapsed.indexOf('in-progress');
                    if (ipIdx > -1) {
                        collapsed.splice(ipIdx, 1);
                    }
                }
            }
            setCollapsedColumns(collapsed);

            // Update DOM directly for smooth animation
            STATUSES.forEach(s => {
                const column = document.querySelector(`.column.${s}`);
                if (column) {
                    if (collapsed.includes(s)) {
                        column.classList.add('collapsed');
                    } else {
                        column.classList.remove('collapsed');
                    }
                }
            });

            // Update grid layout
            updateKanbanGrid();
        }

        // =====================================================================
        // Track-Grouped Kanban (Phase 1: Data Preparation)
        // =====================================================================

        function groupByTrack(nodes) {
            const tracked = new Map(); // track_id -> {track: metadata, features: []}
            const untracked = [];

            nodes.forEach(node => {
                if (node.track_id) {
                    if (!tracked.has(node.track_id)) {
                        tracked.set(node.track_id, {
                            track: null, // Will be populated via API
                            features: []
                        });
                    }
                    tracked.get(node.track_id).features.push(node);
                } else {
                    untracked.push(node);
                }
            });

            return { tracked, untracked };
        }

        async function loadTrackMetadata(trackIds) {
            // Fetch track info from /api/tracks/{id} for each track_id
            const promises = trackIds.map(async (trackId) => {
                try {
                    const response = await fetch(`${API}/tracks/${trackId}`);
                    if (!response.ok) throw new Error(`Track ${trackId} not found`);
                    const track = await response.json();
                    return track;
                } catch (err) {
                    console.error(`Failed to load track ${trackId}:`, err);
                    // Return minimal track object on error
                    return {
                        id: trackId,
                        title: trackId,
                        priority: 'medium',
                        status: 'unknown',
                        has_spec: false,
                        has_plan: false
                    };
                }
            });

            return await Promise.all(promises);
        }

        async function renderKanban(nodes) {
            // Filter to show all work items (exclude sessions, agents, tracks, events)
            const features = nodes.filter(n => {
                const excludedTypes = ['session', 'agent', 'track', 'event'];
                return !excludedTypes.includes(n.type);
            });
            const { tracked, untracked } = groupByTrack(features);
            const tracksWithMetadata = await loadTrackMetadata(Array.from(tracked.keys()));

            // Merge metadata
            tracksWithMetadata.forEach(track => {
                if (tracked.has(track.id)) {
                    tracked.get(track.id).track = track;
                }
            });

            // Sort tracks by feature completion (incomplete first), then by priority
            const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
            const sortedTracks = Array.from(tracked.values())
                // FIXED: Do NOT filter out tracks with null metadata - they still have features to show!
                // Only filter if there are no features for this track
                .filter(t => t.features && t.features.length > 0)
                .sort((a, b) => {
                    // Calculate completion percentage for each track
                    const aTotal = a.features.length;
                    const aDone = a.features.filter(f => f.status === 'done').length;
                    const aComplete = aTotal > 0 ? (aDone === aTotal) : false;

                    const bTotal = b.features.length;
                    const bDone = b.features.filter(f => f.status === 'done').length;
                    const bComplete = bTotal > 0 ? (bDone === bTotal) : false;

                    // Completed tracks go to bottom (1), incomplete stay at top (0)
                    if (aComplete !== bComplete) {
                        return aComplete ? 1 : -1;
                    }

                    // Within same completion status, sort by priority
                    // Use track priority if available, otherwise default to 'medium'
                    const aPriority = (a.track && a.track.priority) || 'medium';
                    const bPriority = (b.track && b.track.priority) || 'medium';
                    return (priorityOrder[aPriority] || 2) - (priorityOrder[bPriority] || 2);
                });

            // Render
            renderTrackSections(sortedTracks);
            renderUntrackedSection(untracked);
        }

        // Shared function to attach event listeners to track sections using event delegation
        function attachTrackEventListeners(containerSelector = '') {
            if (!containerSelector) return; // Require a container selector for proper scoping

            const container = document.querySelector(containerSelector);
            if (!container) {
                console.warn(`Container ${containerSelector} not found for event listeners`);
                return;
            }

            // Check if we've already attached listeners to this container
            if (container.dataset.listenersAttached === 'true') {
                return; // Already attached, don't duplicate
            }

            // Mark as having listeners attached
            container.dataset.listenersAttached = 'true';

            // Use event delegation - attach single listener to container
            container.addEventListener('click', (e) => {
                // Check if click was on a button
                const button = e.target.closest('.track-link-btn');
                if (button && container.contains(button)) {
                    e.stopPropagation(); // Prevent toggle from firing

                    if (button.disabled) return;

                    const trackSection = button.closest('.track-section');
                    if (trackSection) {
                        const trackId = trackSection.dataset.trackId;
                        const trackTitle = trackSection.querySelector('.track-title h3')?.textContent || trackId;

                        // Determine which button was clicked
                        if (button.classList.contains('spec')) {
                            openSpecPlanModal(trackId, 'spec', trackTitle);
                        } else if (button.classList.contains('plan')) {
                            openSpecPlanModal(trackId, 'plan', trackTitle);
                        } else {
                            // The  button (track link)
                            openSpecPlanModal(trackId, 'track', trackTitle);
                        }
                    }
                    return;
                }

                // Check if click was on a track header
                const trackHeader = e.target.closest('.track-header');
                if (trackHeader && container.contains(trackHeader)) {
                    const trackSection = trackHeader.closest('.track-section');
                    if (trackSection) {
                        const trackId = trackSection.dataset.trackId;
                        toggleTrackSection(trackId, containerSelector);
                    }
                    return;
                }

                // Check if click was on a card
                const card = e.target.closest('.track-section .card');
                if (card && container.contains(card)) {
                    openPanel(card.dataset.collection, card.dataset.id);
                    return;
                }
            });
        }

        function renderTrackSections(sortedTracks) {
            const container = document.getElementById('kanban');

            // Clear container for fresh render
            container.innerHTML = '';

            if (sortedTracks.length === 0) {
                // Don't render track sections, but don't return - let untracked section render
                return;
            }

            // Check localStorage for previously expanded track
            const expandedTrackId = localStorage.getItem('expandedTrackId');
            let defaultExpandIndex = 0;

            // If we have a saved expanded track, find its index
            if (expandedTrackId) {
                const savedIndex = sortedTracks.findIndex(t => t.track.id === expandedTrackId);
                if (savedIndex !== -1) {
                    defaultExpandIndex = savedIndex;
                }
            }

            container.innerHTML = `
                <div class="track-sections-container">
                    ${sortedTracks.map((trackData, idx) => renderTrackSection(trackData, idx === defaultExpandIndex)).join('')}
                </div>
            `;

            // Use shared event listener attachment
            attachTrackEventListeners('#kanban');
        }

        function renderTrackSection(trackData, isFirstTrack = false) {
            const { track, features } = trackData;

            // Calculate stats
            const total = features.length;
            const done = features.filter(f => f.status === 'done').length;
            const progress = total > 0 ? Math.round((done / total) * 100) : 0;

            return `
                <div class="track-section ${isFirstTrack ? 'expanded' : ''}" data-track-id="${track.id}">
                    <div class="track-header">
                        <div class="track-title-row">
                            <div class="track-title">
                                <span class="track-icon"></span>
                                <h3>${track.title}</h3>
                                <span class="badge priority-${track.priority}">${track.priority}</span>
                            </div>
                            <div class="track-meta">
                                <button class="track-link-btn spec ${!track.has_spec ? 'disabled' : ''}"
                                        ${!track.has_spec ? 'disabled' : ''}>
                                     Spec
                                </button>
                                <button class="track-link-btn plan ${!track.has_plan ? 'disabled' : ''}"
                                        ${!track.has_plan ? 'disabled' : ''}>
                                     Plan
                                </button>
                                <button class="track-link-btn" title="View track">
                                    
                                </button>
                                <span class="expand-icon"></span>
                            </div>
                        </div>
                        <div class="track-progress-bar">
                            <div class="progress-fill" style="width: ${progress}%"></div>
                            <span class="progress-text">${done}/${total} features</span>
                        </div>
                    </div>
                    <div class="track-content ${isFirstTrack ? '' : 'collapsed'}">
                        ${renderTrackKanban(features)}
                    </div>
                </div>
            `;
        }

        function renderTrackKanban(features) {
            // Group features by status for this track
            const byStatus = {};
            STATUSES.forEach(s => byStatus[s] = []);
            features.forEach(f => {
                if (byStatus[f.status]) byStatus[f.status].push(f);
            });

            return `
                <div class="track-kanban">
                    ${STATUSES.map(status => `
                        <div class="track-column ${status}">
                            <div class="track-column-header">
                                <span class="column-title">${STATUS_LABELS[status]}</span>
                                <span class="column-count">${byStatus[status].length}</span>
                            </div>
                            <div class="track-column-cards">
                                ${byStatus[status].length === 0
                                    ? '<div class="empty-column">No items</div>'
                                    : byStatus[status].map(f => {
                                        // Determine agent badge color based on agent name
                                        let agentClass = 'agent-default';
                                        if (f.agent_assigned) {
                                            const agentName = f.agent_assigned.toLowerCase();
                                            // Primary agents
                                            if (agentName.includes('claude')) agentClass = 'agent-claude';
                                            else if (agentName.includes('codex')) agentClass = 'agent-codex';
                                            else if (agentName.includes('orchestrator')) agentClass = 'agent-orchestrator';
                                            else if (agentName.includes('gemini-2') || agentName.includes('gemini 2')) agentClass = 'agent-gemini-2';
                                            else if (agentName.includes('gemini')) agentClass = 'agent-gemini';
                                            // Secondary agents (backward compatibility)
                                            else if (agentName.includes('analyst')) agentClass = 'agent-analyst';
                                            else if (agentName.includes('developer')) agentClass = 'agent-developer';
                                            else if (agentName.includes('researcher')) agentClass = 'agent-researcher';
                                            else if (agentName.includes('debugger')) agentClass = 'agent-debugger';
                                        }
                                        // Check if feature has delegations
                                        const delegations = (f.properties && f.properties.delegations) || [];
                                        const delegationBadges = delegations.length > 0
                                            ? `<span class="badge delegation" title="Delegated to ${delegations.length} spawner(s)">Delegated: ${delegations.length}</span>`
                                            : '';
                                        return `
                                        <div class="card priority-${f.priority}"
                                             data-collection="${f._collection}"
                                             data-id="${f.id}"
                                             data-agent="${f.agent_assigned || ''}"
                                             onclick="toggleCardTimeline(event)">
                                            <button class="card-expand-btn" onclick="toggleCardTimeline(event)" title="Toggle agent timeline"></button>
                                            <div class="card-title">${f.title}</div>
                                            <div class="card-meta">
                                                <span class="badge priority-${f.priority}">${f.priority}</span>
                                                ${f.type !== 'feature' ? `<span class="badge type">${f.type}</span>` : ''}
                                                ${f.agent_assigned ? `<span class="badge agent ${agentClass}">${f.agent_assigned}</span>` : ''}
                                                ${delegationBadges}
                                                <span class="card-path">${f._collection}/${f.id}</span>
                                            </div>
                                            <div class="card-timeline" data-feature-id="${f.id}">
                                                <div class="timeline-header">Agent Timeline</div>
                                                <div class="timeline-list" data-loading="true">
                                                    <div class="timeline-empty">Loading timeline...</div>
                                                </div>
                                            </div>
                                        </div>
                                    `}).join('')}
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function toggleTrackSection(trackId, containerSelector = '') {
            const baseSelector = containerSelector || '';
            const allSectionsSelector = baseSelector ? `${baseSelector} .track-section` : '.track-section';
            const targetSelector = baseSelector ? `${baseSelector} .track-section[data-track-id="${trackId}"]` : `.track-section[data-track-id="${trackId}"]`;

            const allSections = document.querySelectorAll(allSectionsSelector);
            const targetSection = document.querySelector(targetSelector);

            if (!targetSection) return;

            const isCurrentlyExpanded = targetSection.classList.contains('expanded');

            // Collapse all sections in this container
            allSections.forEach(section => {
                section.classList.remove('expanded');
                const content = section.querySelector('.track-content');
                if (content) content.classList.add('collapsed');
            });

            // If it wasn't expanded, expand it now
            if (!isCurrentlyExpanded) {
                targetSection.classList.add('expanded');
                const content = targetSection.querySelector('.track-content');
                if (content) content.classList.remove('collapsed');

                // Store in localStorage
                localStorage.setItem('expandedTrackId', trackId);
            } else {
                // If it was expanded and we collapsed it, clear localStorage
                localStorage.removeItem('expandedTrackId');
            }
        }

        function renderUntrackedSection(untracked) {
            if (untracked.length === 0) return;

            const container = document.getElementById('kanban');
            const done = untracked.filter(f => f.status === 'done').length;
            const total = untracked.length;
            const progress = total > 0 ? Math.round((done / total) * 100) : 0;

            // Check localStorage for untracked section state
            const isExpanded = localStorage.getItem('untrackedExpanded') === 'true';

            container.innerHTML += `
                <div class="untracked-section ${isExpanded ? 'expanded' : ''}" data-section-id="untracked">
                    <div class="untracked-header" onclick="toggleUntrackedSection()">
                        <div class="track-title-row">
                            <div class="untracked-title">
                                <span class="untracked-icon"></span>
                                <h3>Untracked Features</h3>
                                <span class="badge priority-medium">No Track</span>
                            </div>
                            <div class="untracked-meta">
                                <span class="expand-icon"></span>
                            </div>
                        </div>
                        <div class="track-progress-bar">
                            <div class="progress-fill" style="width: ${progress}%"></div>
                            <span class="progress-text">${done}/${total} features</span>
                        </div>
                    </div>
                    <div class="untracked-content ${isExpanded ? '' : 'collapsed'}">
                        ${renderTrackKanban(untracked)}
                    </div>
                </div>
            `;

            // Add card click handlers for untracked section
            document.querySelectorAll('.untracked-section .card').forEach(card => {
                card.addEventListener('click', () => {
                    openPanel(card.dataset.collection, card.dataset.id);
                });
            });
        }

        function toggleUntrackedSection() {
            const section = document.querySelector('.untracked-section');
            if (!section) return;

            const isExpanded = section.classList.contains('expanded');
            const content = section.querySelector('.untracked-content');

            if (isExpanded) {
                section.classList.remove('expanded');
                if (content) content.classList.add('collapsed');
                localStorage.removeItem('untrackedExpanded');
            } else {
                section.classList.add('expanded');
                if (content) content.classList.remove('collapsed');
                localStorage.setItem('untrackedExpanded', 'true');
            }
        }

        // =====================================================================
        // Panel
        // =====================================================================

        function openPanel(collection, id) {
            const panel = document.getElementById('panel');
            const overlay = document.getElementById('panel-overlay');

            panel.classList.add('open');
            overlay.classList.add('open');

            renderPanelLoading();

            loadNode(collection, id).then(node => {
                currentNode = node;
                currentNode._collection = collection;
                renderPanel(node);
            }).catch(err => {
                renderPanelError(err.message);
            });
        }

        function closePanel() {
            const panel = document.getElementById('panel');
            const overlay = document.getElementById('panel-overlay');
            panel.classList.remove('open');
            overlay.classList.remove('open');
            currentNode = null;
        }

        async function fetchActivityLog(collection, sessionId) {
            const container = document.getElementById('activity-log-container');

            try {
                // Use Analytics API to get merged events (including child sessions)
                const response = await fetch(`${API}/analytics/session?id=${sessionId}&limit=100`);
                if (!response.ok) throw new Error('Failed to load session events');

                const data = await response.json();
                const events = data.events || [];

                if (events.length === 0) {
                    container.innerHTML = '<div class="loading">No events recorded</div>';
                    return;
                }

                let html_content = `
                    <div class="activity-header">
                        <strong>${events.length}</strong>
                        <span>(most recent first)</span>
                    </div>
                    <ol class="activity-list" reversed>
                `;

                events.forEach(item => {
                    const ts = new Date(item.ts).toLocaleString();
                    const tool = item.tool || 'Unknown';
                    const success = item.success === 1 || item.success === true;
                    const feature = item.feature_id || '';
                    const drift = item.drift_score ? parseFloat(item.drift_score).toFixed(2) : '';
                    const content = item.summary || '';
                    
                    // Identify child events (from sub-sessions)
                    const isChild = item.session_id !== sessionId;
                    const childClass = isChild ? 'child-event' : '';
                    const childBadge = isChild ? '<span class="badge" style="background: var(--bg-tertiary); color: var(--text-muted);">sub-task</span>' : '';

                    const statusIcon = success ? '' : '';
                    const featureBadge = feature ? `<span class="badge">${feature}</span>` : '';
                    const driftBadge = drift ? `<span class="badge drift-${drift >= 0.7 ? 'high' : 'low'}">drift: ${drift}</span>` : '';

                    html_content += `
                        <li class="activity-item ${childClass}" style="${isChild ? 'padding-left: 1.5rem; border-left: 2px solid var(--border);' : ''}">
                            <div class="activity-meta">
                                <span class="activity-time">${ts}</span>
                                ${statusIcon}
                                <span class="activity-tool">${tool}</span>
                                ${childBadge}
                                ${featureBadge}
                                ${driftBadge}
                            </div>
                            <div class="activity-content">${escapeHtml(content)}</div>
                        </li>
                    `;
                });

                html_content += `</ol>`;
                container.innerHTML = html_content;

            } catch (err) {
                console.error("Activity log error:", err);
                container.innerHTML = `<div class="loading">Error loading activity log: ${err.message}</div>`;
            }
        }

        async function fetchTranscriptStats(sessionId) {
            const container = document.getElementById('transcript-stats-container');
            if (!container) return;

            try {
                const response = await fetch(`${API}/sessions/${sessionId}?transcript=true`);
                if (!response.ok) throw new Error('Failed to load transcript stats');

                const data = await response.json();

                if (!data.transcript_linked) {
                    container.innerHTML = `
                        <div class="transcript-not-linked">
                            <span style="color: var(--text-muted);">No Claude Code transcript linked</span>
                            <div style="font-size: 0.75rem; margin-top: 0.5rem; color: var(--text-muted);">
                                Transcripts are linked automatically on work item completion
                            </div>
                        </div>
                    `;
                    return;
                }

                // Format duration
                let durationStr = '';
                if (data.duration_seconds) {
                    const mins = Math.floor(data.duration_seconds / 60);
                    const secs = Math.floor(data.duration_seconds % 60);
                    durationStr = mins > 0 ? `${mins}m ${secs}s` : `${secs}s`;
                }

                // Build tool breakdown
                let toolBreakdownHtml = '';
                if (data.tool_breakdown && Object.keys(data.tool_breakdown).length > 0) {
                    const sortedTools = Object.entries(data.tool_breakdown)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 8);
                    toolBreakdownHtml = `
                        <div class="transcript-tools" style="margin-top: 0.75rem;">
                            <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.25rem;">Tool Usage:</div>
                            <div style="display: flex; flex-wrap: wrap; gap: 0.25rem;">
                                ${sortedTools.map(([tool, count]) => `
                                    <span class="badge" style="font-size: 0.7rem;">${tool}: ${count}</span>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }

                container.innerHTML = `
                    <div class="transcript-stats">
                        <div class="transcript-meta" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; margin-bottom: 0.75rem;">
                            <div><strong>User Messages:</strong> ${data.user_messages || 0}</div>
                            <div><strong>Tool Calls:</strong> ${data.tool_calls || 0}</div>
                            <div><strong>Duration:</strong> ${durationStr}</div>
                            <div><strong>Total Entries:</strong> ${data.entry_count || 0}</div>
                        </div>
                        <div class="transcript-badges" style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            ${data.has_thinking_traces ? '<span class="badge" style="background: var(--accent);">Has Thinking Traces</span>' : ''}
                            ${data.git_branch ? `<span class="badge">Branch: ${data.git_branch}</span>` : ''}
                        </div>
                        ${toolBreakdownHtml}
                        <div class="transcript-id" style="margin-top: 0.75rem; font-size: 0.7rem; color: var(--text-muted);">
                            Transcript ID: <code style="font-family: monospace;">${data.transcript_id || ''}</code>
                        </div>
                    </div>
                `;
            } catch (err) {
                container.innerHTML = `<div class="loading">Error loading transcript: ${err.message}</div>`;
            }
        }

        function renderPanelLoading() {
            document.getElementById('panel-title').textContent = 'Loading...';
            document.getElementById('panel-body').innerHTML = '<div class="loading">Loading...</div>';
            document.getElementById('panel-actions').innerHTML = '';
        }

        function renderPanelError(message) {
            document.getElementById('panel-title').textContent = 'Error';
            document.getElementById('panel-body').innerHTML = `<div class="loading">${message}</div>`;
            document.getElementById('panel-actions').innerHTML = '';
        }

        function renderPanel(node) {
            document.getElementById('panel-title').textContent = node.title;

            let bodyHtml = '';

            // Helper function to get agent badge class
            function getAgentClass(agentName) {
                if (!agentName) return 'agent-default';
                const name = agentName.toLowerCase();
                // Primary agents
                if (name.includes('claude')) return 'agent-claude';
                if (name.includes('codex')) return 'agent-codex';
                if (name.includes('orchestrator')) return 'agent-orchestrator';
                if (name.includes('gemini-2') || name.includes('gemini 2')) return 'agent-gemini-2';
                if (name.includes('gemini')) return 'agent-gemini';
                // Secondary agents (backward compatibility)
                if (name.includes('analyst')) return 'agent-analyst';
                if (name.includes('developer')) return 'agent-developer';
                if (name.includes('researcher')) return 'agent-researcher';
                if (name.includes('debugger')) return 'agent-debugger';
                return 'agent-default';
            }

            // Meta section
            bodyHtml += `
                <div class="panel-section">
                    <h3>Details</h3>
                    <div class="panel-meta">
                        <span class="badge priority-${node.priority}">${node.priority}</span>
                        <span class="badge type">${node.type}</span>
                        <span class="badge">${node.status}</span>
                        ${node.agent_assigned ? `<span class="badge agent ${getAgentClass(node.agent_assigned)}">Agent: ${node.agent_assigned}</span>` : ''}
                    </div>
                </div>
            `;

            // Steps section
            if (node.steps && node.steps.length > 0) {
                const completedCount = node.steps.filter(s => s.completed).length;
                bodyHtml += `
                    <div class="panel-section">
                        <h3>Steps (${completedCount}/${node.steps.length})</h3>
                        <ul class="steps-list">
                            ${node.steps.map((step, i) => `
                                <li class="step-item">
                                    <input type="checkbox" class="step-checkbox"
                                           data-index="${i}"
                                           ${step.completed ? 'checked' : ''}
                                           ${node.status === 'done' ? 'disabled' : ''}>
                                    <div>
                                        <div class="step-text ${step.completed ? 'completed' : ''}">${step.description}</div>
                                        ${step.agent ? `<div class="step-agent">by ${step.agent}</div>` : ''}
                                    </div>
                                </li>
                            `).join('')}
                        </ul>
                    </div>
                `;
            }

            // Delegation information section (if delegation data exists in properties)
            if (node.properties && (node.properties.delegated_tasks || node.properties.delegations)) {
                const delegations = node.properties.delegations || node.properties.delegated_tasks || [];
                if (delegations && delegations.length > 0) {
                    bodyHtml += `
                        <div class="panel-section">
                            <h3>Delegations (${delegations.length})</h3>
                            <div class="delegations-list">
                                ${delegations.map((d, idx) => {
                                    const spawner = d.spawner || d.executor || 'unknown';
                                    const executorType = d.executor_type || 'direct';
                                    let executorBadge = 'delegation-direct';
                                    if (executorType === 'external_cli') executorBadge = 'delegation-external';
                                    else if (executorType === 'fallback') executorBadge = 'delegation-fallback';

                                    const tokens = d.tokens_used ? ` (${d.tokens_used} tokens)` : '';
                                    const cost = d.cost ? ` - $${d.cost.toFixed(2)}` : '';

                                    return `
                                        <div class="delegation-item">
                                            <div class="delegation-meta">
                                                <span class="badge delegation ${executorBadge}">${spawner}</span>
                                                <span class="badge delegation">${executorType}</span>
                                                ${tokens ? `<span class="mono">${tokens}</span>` : ''}
                                                ${cost ? `<span class="mono">${cost}</span>` : ''}
                                            </div>
                                            ${d.task_id ? `<div class="delegation-task">Task: ${d.task_id}</div>` : ''}
                                            ${d.timestamp ? `<div class="delegation-time">${new Date(d.timestamp).toLocaleString()}</div>` : ''}
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                }
            }

            // Edges section (excluding implemented-in which gets special handling)
            const edgeTypes = Object.keys(node.edges || {}).filter(t => t !== 'implemented-in');
            if (edgeTypes.length > 0) {
                bodyHtml += `<div class="panel-section"><h3>Relationships</h3>`;
                edgeTypes.forEach(edgeType => {
                    const edges = node.edges[edgeType];
                    if (edges && edges.length > 0) {
                        bodyHtml += `
                            <ul class="edge-list">
                                ${edges.map(e => `
                                    <li class="edge-item">
                                        <a data-target="${e.target_id}">${e.title || e.target_id}</a>
                                        <span class="edge-type">${edgeType}</span>
                                    </li>
                                `).join('')}
                            </ul>
                        `;
                    }
                });
                bodyHtml += `</div>`;
            }

            // Session previews (implemented-in edges)
            const sessionEdges = (node.edges || {})['implemented-in'] || [];
            if (sessionEdges.length > 0) {
                bodyHtml += `
                    <div class="panel-section">
                        <h3>Sessions (${sessionEdges.length})</h3>
                        <div id="session-previews">
                            ${sessionEdges.map(e => `
                                <div class="session-preview" data-session-id="${e.target_id}">
                                    <div class="session-preview-header" onclick="toggleSessionPreview('${e.target_id}')">
                                        <span class="session-preview-title">${e.target_id}</span>
                                        <span class="session-preview-meta">
                                            <span>Loading...</span>
                                        </span>
                                    </div>
                                    <div class="session-preview-body collapsed" id="session-body-${e.target_id}">
                                        <div class="activity-entry">Loading activity log...</div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            // Content section
            if (node.content) {
                bodyHtml += `
                    <div class="panel-section">
                        <h3>Description</h3>
                        <div class="panel-content">${node.content}</div>
                    </div>
                `;
            }

            // Properties section
            if (node.properties && Object.keys(node.properties).length > 0) {
                bodyHtml += `
                    <div class="panel-section">
                        <h3>Properties</h3>
                        <div class="panel-content">
                            ${Object.entries(node.properties).map(([k, v]) => `<div><strong>${k}:</strong> ${v}</div>`).join('')}
                        </div>
                    </div>
                `;
            }

            // Activity Log (for sessions only)
            if (node.type === 'session') {
                bodyHtml += `
                    <div class="panel-section">
                        <h3>Activity Log</h3>
                        <div id="activity-log-container" class="loading">Loading activity log...</div>
                    </div>
                `;

                // Transcript section (for sessions only)
                bodyHtml += `
                    <div class="panel-section">
                        <h3>Claude Code Transcript</h3>
                        <div id="transcript-stats-container" class="loading">Loading transcript data...</div>
                    </div>
                `;
            }

            // Timestamps
            bodyHtml += `
                <div class="panel-section">
                    <h3>Timestamps</h3>
                    <div class="panel-timestamps">
                        <div>Created: ${new Date(node.created).toLocaleString()}</div>
                        <div>Updated: ${new Date(node.updated).toLocaleString()}</div>
                    </div>
                </div>
            `;

            document.getElementById('panel-body').innerHTML = bodyHtml;

            // Load activity log and transcript stats for sessions
            if (node.type === 'session') {
                fetchActivityLog(node._collection || 'sessions', node.id);
                fetchTranscriptStats(node.id);
            }

            // Actions
            let actionsHtml = '';

            if (node.type !== 'epic') {
                if (node.status === 'todo') {
                    actionsHtml += `<button class="btn btn-primary" data-action="start">Start</button>`;
                }
                if (node.status === 'in-progress') {
                    actionsHtml += `<button class="btn btn-success" data-action="complete">Done</button>`;
                    actionsHtml += `<button class="btn btn-danger" data-action="block">Block</button>`;
                }
                if (node.status === 'blocked') {
                    actionsHtml += `<button class="btn btn-primary" data-action="unblock">Unblock</button>`;
                }
                if (node.status === 'done') {
                    actionsHtml += `<button class="btn" data-action="reopen">Reopen</button>`;
                }
            }

            document.getElementById('panel-actions').innerHTML = actionsHtml;
            addPanelEventListeners();
        }

        function addPanelEventListeners() {
            // Step checkboxes
            document.querySelectorAll('.step-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', async (e) => {
                    const index = parseInt(e.target.dataset.index);
                    const completed = e.target.checked;

                    if (completed && currentNode) {
                        try {
                            const updated = await updateNode(
                                currentNode._collection,
                                currentNode.id,
                                { complete_step: index, agent: 'user' }
                            );
                            currentNode = { ...updated, _collection: currentNode._collection };
                            renderPanel(currentNode);
                            refreshDashboard();
                        } catch (err) {
                            e.target.checked = !completed;
                            alert('Failed to update step');
                        }
                    }
                });
            });

            // Edge links
            document.querySelectorAll('.edge-item a').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const targetId = e.target.dataset.target;
                    const targetNode = allNodes.find(n => n.id === targetId);
                    if (targetNode) {
                        openPanel(targetNode._collection, targetNode.id);
                    }
                });
            });

            // Action buttons
            document.querySelectorAll('[data-action]').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const action = btn.dataset.action;
                    if (!currentNode) return;

                    let update = {};
                    switch (action) {
                        case 'start':
                            update = { status: 'in-progress', agent_assigned: 'user' };
                            break;
                        case 'complete':
                            update = { status: 'done' };
                            break;
                        case 'block':
                            update = { status: 'blocked' };
                            break;
                        case 'unblock':
                            update = { status: 'in-progress' };
                            break;
                        case 'reopen':
                            update = { status: 'todo', agent_assigned: null };
                            break;
                    }

                    try {
                        btn.disabled = true;
                        const updated = await updateNode(currentNode._collection, currentNode.id, update);
                        currentNode = { ...updated, _collection: currentNode._collection };
                        renderPanel(currentNode);
                        refreshDashboard();
                    } catch (err) {
                        alert('Failed to update: ' + err.message);
                    } finally {
                        btn.disabled = false;
                    }
                });
            });
        }

        // =====================================================================
        // Session Preview
        // =====================================================================

        const sessionCache = new Map();

        async function toggleSessionPreview(sessionId) {
            const body = document.getElementById(`session-body-${sessionId}`);
            if (!body) return;

            const isCollapsed = body.classList.contains('collapsed');

            if (isCollapsed) {
                // Expand and load if needed
                body.classList.remove('collapsed');
                if (!sessionCache.has(sessionId)) {
                    await loadSessionPreview(sessionId);
                }
            } else {
                // Collapse
                body.classList.add('collapsed');
            }
        }

        async function loadSessionPreview(sessionId) {
            const body = document.getElementById(`session-body-${sessionId}`);
            const preview = document.querySelector(`.session-preview[data-session-id="${sessionId}"]`);
            if (!body || !preview) return;

            try {
                // Fetch session HTML and parse it
                const response = await fetch(`.htmlgraph/sessions/${sessionId}.html`);
                if (!response.ok) throw new Error('Session not found');

                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');

                // Extract session metadata
                const article = doc.querySelector('article[data-type="session"]');
                const status = article?.getAttribute('data-status') || 'unknown';
                const eventCount = article?.getAttribute('data-event-count') || '0';
                const agent = article?.getAttribute('data-agent') || 'unknown';

                // Update header meta
                const metaEl = preview.querySelector('.session-preview-meta');
                if (metaEl) {
                    metaEl.innerHTML = `
                        <span class="badge">${status}</span>
                        <span>${eventCount} events</span>
                        <span>${agent}</span>
                    `;
                }

                // Extract activity log entries
                const entries = doc.querySelectorAll('section[data-activity-log] ol li');
                const activities = [];

                entries.forEach(li => {
                    const tool = li.getAttribute('data-tool') || 'unknown';
                    const ts = li.getAttribute('data-ts');
                    const drift = li.getAttribute('data-drift');
                    let summary = li.textContent.trim();

                    // Remove tool prefix from summary if present (avoid duplication)
                    if (summary.startsWith(tool + ':')) {
                        summary = summary.substring(tool.length + 1).trim();
                    } else if (summary.startsWith(tool + ' ')) {
                        summary = summary.substring(tool.length + 1).trim();
                    }

                    // Skip SessionStart/SessionEnd for cleaner display
                    if (tool === 'SessionStart' || tool === 'SessionEnd') return;

                    activities.push({ tool, ts, drift, summary });
                });

                // Render activity log (most recent first, already in that order from HTML)
                if (activities.length > 0) {
                    body.innerHTML = activities.slice(0, 10).map(a => `
                        <div class="activity-entry">
                            <span class="activity-tool ${a.tool}">${a.tool}</span>
                            <span class="activity-summary">${escapeHtml(a.summary)}</span>
                            ${a.drift && parseFloat(a.drift) > 0.3 ? `<span class="drift-warning"> ${a.drift}</span>` : ''}
                            ${a.ts ? `<span class="activity-time">${new Date(a.ts).toLocaleTimeString()}</span>` : ''}
                        </div>
                    `).join('');

                    if (activities.length > 10) {
                        body.innerHTML += `<div class="activity-entry" style="color: var(--text-muted);">... and ${activities.length - 10} more</div>`;
                    }
                } else {
                    body.innerHTML = '<div class="activity-entry" style="color: var(--text-muted);">No activities recorded</div>';
                }

                // Cache the result
                sessionCache.set(sessionId, { status, eventCount, activities });

            } catch (err) {
                body.innerHTML = `<div class="activity-entry" style="color: var(--priority-critical);">Failed to load: ${err.message}</div>`;
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function refreshDashboard() {
            const { status, nodes } = await loadData();
            await renderKanban(nodes);
            updateKanbanGrid();
        }

        // =====================================================================
        // Graph Visualization
        // =====================================================================

        let visNetwork = null;  // Vis.js network instance

        function getNodeColor(node) {
            const colors = {
                'done': getComputedStyle(document.documentElement).getPropertyValue('--status-done').trim(),
                'in-progress': getComputedStyle(document.documentElement).getPropertyValue('--status-active').trim(),
                'blocked': getComputedStyle(document.documentElement).getPropertyValue('--status-blocked').trim(),
                'todo': getComputedStyle(document.documentElement).getPropertyValue('--status-todo').trim()
            };
            return colors[node.status] || colors['todo'];
        }

        function getNodeRadius(node) {
            const statusSizes = {
                'done': 20,
                'in-progress': 35,
                'blocked': 30,
                'todo': 28
            };
            return statusSizes[node.status] || 25;
        }

        function wrapText(text, maxCharsPerLine = 10) {
            const words = text.split(/\s+/);
            const lines = [];
            let currentLine = '';

            for (const word of words) {
                const testLine = currentLine ? currentLine + ' ' + word : word;
                if (testLine.length <= maxCharsPerLine) {
                    currentLine = testLine;
                } else {
                    if (currentLine) lines.push(currentLine);
                    currentLine = word.length > maxCharsPerLine
                        ? word.substring(0, maxCharsPerLine - 1) + ''
                        : word;
                }
            }
            if (currentLine) lines.push(currentLine);

            if (lines.length > 3) {
                lines.length = 3;
                lines[2] = lines[2].substring(0, lines[2].length - 1) + '';
            }

            return lines.join('\n');
        }

        function buildGraphData(nodes) {
            const graphNodes = nodes.map(n => ({
                id: n.id,
                title: n.title,
                status: n.status,
                type: n.type,
                priority: n.priority,
                edges: n.edges || {},
                _collection: n._collection
            }));

            const nodeIds = new Set(nodes.map(n => n.id));
            const graphEdges = [];

            nodes.forEach(node => {
                Object.entries(node.edges || {}).forEach(([edgeType, edges]) => {
                    edges.forEach(edge => {
                        if (nodeIds.has(edge.target_id)) {
                            graphEdges.push({
                                from: node.id,
                                to: edge.target_id,
                                type: edgeType
                            });
                        }
                    });
                });
            });

            return { nodes: graphNodes, edges: graphEdges };
        }

        // Graph State Management
        let graphState = {
            allNodes: [],
            allEdges: [],
            visibleNodeIds: new Set(),
            searchQuery: '',
            filters: {
                todo: true,
                'in-progress': true,
                blocked: true,
                done: false
            }
        };

        function applyGraphFilters() {
            const filters = {};
            document.querySelectorAll('.graph-filter-checkbox input').forEach(cb => {
                filters[cb.dataset.status] = cb.checked;
            });

            graphState.filters = filters;
            graphState.searchQuery = (document.getElementById('graph-search')?.value || '').toLowerCase();

            // Determine visible nodes
            graphState.visibleNodeIds = new Set();
            graphState.allNodes.forEach(node => {
                const statusMatch = filters[node.status] || false;
                const searchMatch = !graphState.searchQuery || node.title.toLowerCase().includes(graphState.searchQuery);
                if (statusMatch && searchMatch) {
                    graphState.visibleNodeIds.add(node.id);
                }
            });

            // Update Vis.js network with visible nodes and edges
            if (visNetwork) {
                const visibleNodes = graphState.allNodes.filter(n => graphState.visibleNodeIds.has(n.id));
                const visibleEdges = graphState.allEdges.filter(e => 
                    graphState.visibleNodeIds.has(e.from) && graphState.visibleNodeIds.has(e.to)
                );

                const nodesDataset = new vis.DataSet(visibleNodes.map(n => ({
                    id: n.id,
                    label: wrapText(n.title),
                    title: n.title + '\nStatus: ' + n.status,
                    color: {
                        background: getNodeColor(n),
                        border: getComputedStyle(document.documentElement).getPropertyValue('--border-strong').trim(),
                        highlight: {
                            background: getNodeColor(n),
                            border: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim()
                        }
                    },
                    size: getNodeRadius(n),
                    font: {
                        size: 12,
                        face: "'JetBrains Mono', monospace",
                        color: 'white',
                        strokeWidth: 0
                    },
                    physics: true,
                    borderWidth: 2,
                    status: n.status,
                    _collection: n._collection,
                    x: undefined,  // Let physics handle positioning
                    y: undefined
                })));

                const edgesDataset = new vis.DataSet(visibleEdges.map(e => ({
                    from: e.from,
                    to: e.to,
                    arrows: 'to',
                    smooth: { type: 'continuous' },
                    color: e.type === 'blocked_by' 
                        ? { color: getComputedStyle(document.documentElement).getPropertyValue('--status-blocked').trim(), highlight: getComputedStyle(document.documentElement).getPropertyValue('--status-blocked').trim() }
                        : { color: getComputedStyle(document.documentElement).getPropertyValue('--status-active').trim(), highlight: getComputedStyle(document.documentElement).getPropertyValue('--status-active').trim() },
                    dashes: e.type === 'blocked_by' ? [6, 4] : false,
                    width: 1.5
                })));

                visNetwork.setData({ nodes: nodesDataset, edges: edgesDataset });
            }

            updateGraphStats();
            localStorage.setItem('graphFilters', JSON.stringify(graphState.filters));
        }

        function updateGraphStats() {
            const visibleNodeCount = graphState.visibleNodeIds.size;
            const visibleEdgeCount = graphState.allEdges.filter(e => 
                graphState.visibleNodeIds.has(e.from) && graphState.visibleNodeIds.has(e.to)
            ).length;
            const nodeCountEl = document.getElementById('graph-node-count');
            const edgeCountEl = document.getElementById('graph-edge-count');
            if (nodeCountEl) nodeCountEl.textContent = `${visibleNodeCount} nodes`;
            if (edgeCountEl) edgeCountEl.textContent = `${visibleEdgeCount} edges`;
        }

        function resetGraphView() {
            const searchEl = document.getElementById('graph-search');
            if (searchEl) searchEl.value = '';
            graphState.searchQuery = '';
            applyGraphFilters();
            if (visNetwork) visNetwork.fit();
        }

        function showAllNodes() {
            document.querySelectorAll('.graph-filter-checkbox input').forEach(cb => {
                cb.checked = true;
            });
            graphState.filters = { todo: true, 'in-progress': true, blocked: true, done: true };
            applyGraphFilters();
            if (visNetwork) visNetwork.fit();
        }

        function renderGraph(nodes) {
            if (nodes.length === 0) {
                if (visNetwork) visNetwork.destroy();
                visNetwork = null;
                return;
            }

            const { nodes: graphNodes, edges: graphEdges } = buildGraphData(nodes);

            graphState.allNodes = graphNodes;
            graphState.allEdges = graphEdges;

            // FILTER FIRST: Apply default filters before rendering
            // Default: show todo, in-progress, blocked (exclude done items)
            graphState.visibleNodeIds = new Set();
            graphState.allNodes.forEach(node => {
                if (graphState.filters[node.status] !== false) {
                    graphState.visibleNodeIds.add(node.id);
                }
            });

            // Only render visible nodes and edges
            const visibleNodes = graphState.allNodes.filter(n => graphState.visibleNodeIds.has(n.id));
            const visibleEdges = graphState.allEdges.filter(e =>
                graphState.visibleNodeIds.has(e.from) && graphState.visibleNodeIds.has(e.to)
            );

            // Create Vis.js nodes dataset with FILTERED nodes only
            const nodesData = new vis.DataSet(visibleNodes.map(n => ({
                id: n.id,
                label: wrapText(n.title),
                title: n.title + '\nStatus: ' + n.status,
                color: {
                    background: getNodeColor(n),
                    border: getComputedStyle(document.documentElement).getPropertyValue('--border-strong').trim(),
                    highlight: {
                        background: getNodeColor(n),
                        border: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim()
                    }
                },
                size: getNodeRadius(n),
                font: {
                    size: 12,
                    face: "'JetBrains Mono', monospace",
                    color: 'white',
                    strokeWidth: 0
                },
                physics: true,
                borderWidth: 2,
                status: n.status,
                _collection: n._collection
            })));

            // Create Vis.js edges dataset with FILTERED edges only
            const edgesData = new vis.DataSet(visibleEdges.map(e => ({
                from: e.from,
                to: e.to,
                arrows: 'to',
                smooth: { type: 'continuous' },
                color: e.type === 'blocked_by'
                    ? { color: getComputedStyle(document.documentElement).getPropertyValue('--status-blocked').trim(), highlight: getComputedStyle(document.documentElement).getPropertyValue('--status-blocked').trim() }
                    : { color: getComputedStyle(document.documentElement).getPropertyValue('--status-active').trim(), highlight: getComputedStyle(document.documentElement).getPropertyValue('--status-active').trim() },
                dashes: e.type === 'blocked_by' ? [6, 4] : false,
                width: 1.5
            })));

            // Destroy existing network if it exists
            if (visNetwork) {
                visNetwork.destroy();
            }

            // Create new Vis.js network
            const container = document.getElementById('graph-network');
            const data = {
                nodes: nodesData,
                edges: edgesData
            };

            // Optimize physics based on node count
            const nodeCount = visibleNodes.length;
            const stabilizationIterations = nodeCount > 300 ? 100 : (nodeCount > 150 ? 150 : 200);

            const options = {
                physics: {
                    enabled: true,
                    stabilization: {
                        iterations: stabilizationIterations,
                        fit: true
                    },
                    barnesHut: {
                        gravitationalConstant: -30000,
                        centralGravity: 0.3,
                        springLength: 200,
                        springConstant: 0.04
                    },
                    maxVelocity: 50
                },
                interaction: {
                    navigationButtons: true,
                    keyboard: true,
                    zoomView: true,
                    dragView: true
                },
                nodes: {
                    shape: 'circle',
                    scaling: {
                        min: 10,
                        max: 50
                    }
                }
            };

            visNetwork = new vis.Network(container, data, options);

            // Handle node clicks
            visNetwork.on('click', (params) => {
                if (params.nodes.length > 0) {
                    const nodeId = params.nodes[0];
                    const node = graphState.allNodes.find(n => n.id === nodeId);
                    if (node) {
                        openPanel(node._collection, node.id);
                    }
                }
            });

            // Apply filters after network is initialized
            applyGraphFilters();
        }

        // =====================================================================
        // Agent Skills Analysis
        // =====================================================================

        function analyzeAgentSkills(sessions) {
            const skillProfiles = {};
            const agents = [...new Set(sessions.map(s => s.properties?.agent).filter(Boolean))];
            agents.forEach(agent => {
                skillProfiles[agent] = {Implementation: 0, Analysis: 0, Testing: 0, Documentation: 0, Coordination: 0};
            });
            sessions.forEach(session => {
                const agent = session.properties?.agent;
                if (!agent) return;
                const desc = (session.name || session.id || '').toLowerCase();
                const cnt = session.properties?.event_count || 0;
                if (desc.includes('test') || desc.includes('validate')) skillProfiles[agent].Testing += Math.min(cnt / 10, 2);
                if (desc.includes('implement') || desc.includes('code') || desc.includes('build')) skillProfiles[agent].Implementation += Math.min(cnt / 10, 2);
                if (desc.includes('analyze') || desc.includes('research')) skillProfiles[agent].Analysis += Math.min(cnt / 10, 2);
                if (desc.includes('document') || desc.includes('explain')) skillProfiles[agent].Documentation += Math.min(cnt / 10, 2);
                if (desc.includes('coordinate') || desc.includes('delegate')) skillProfiles[agent].Coordination += Math.min(cnt / 10, 2);
                if (agent.includes('Claude')) {
                    skillProfiles[agent].Analysis = Math.max(skillProfiles[agent].Analysis, 4.5);
                    skillProfiles[agent].Documentation = Math.max(skillProfiles[agent].Documentation, 4);
                }
                if (agent.includes('Codex')) {
                    skillProfiles[agent].Implementation = Math.max(skillProfiles[agent].Implementation, 5);
                    skillProfiles[agent].Testing = Math.max(skillProfiles[agent].Testing, 4);
                }
                if (agent.includes('Orchestrator')) {
                    skillProfiles[agent].Coordination = Math.max(skillProfiles[agent].Coordination, 5);
                    skillProfiles[agent].Analysis = Math.max(skillProfiles[agent].Analysis, 4);
                }
                if (agent.includes('Gemini')) {
                    skillProfiles[agent].Analysis = Math.max(skillProfiles[agent].Analysis, 4.5);
                    skillProfiles[agent].Implementation = Math.max(skillProfiles[agent].Implementation, 3);
                }
            });
            agents.forEach(agent => {
                Object.keys(skillProfiles[agent]).forEach(skill => {
                    skillProfiles[agent][skill] = Math.min(5, Math.max(1, skillProfiles[agent][skill]));
                });
            });
            return { agents, skillProfiles };
        }

        function getProficiencyColor(level) {
            return `proficiency-${Math.round(level)}`;
        }

        function getProficiencyLabel(level) {
            const labels = ['', 'Novice', 'Beginner', 'Intermediate', 'Advanced', 'Expert'];
            return labels[Math.round(level)] || 'Expert';
        }

        function renderSkillsMatrix(agents, skillProfiles) {
            const skills = ['Implementation', 'Analysis', 'Testing', 'Documentation', 'Coordination'];
            let html = '<div class="skills-matrix">';
            html += '<div class="skills-matrix-cell skills-matrix-header-row">AGENT</div>';
            skills.forEach(skill => html += `<div class="skills-matrix-cell skills-matrix-header-row">${skill}</div>`);
            agents.forEach(agent => {
                html += `<div class="skills-matrix-cell skills-matrix-agent-name">${agent}</div>`;
                skills.forEach(skill => {
                    const level = skillProfiles[agent][skill];
                    const rnd = Math.round(level);
                    html += `<div class="skills-matrix-cell"><div class="proficiency-dot ${getProficiencyColor(level)}" title="${getProficiencyLabel(level)} (${rnd}/5)">${rnd}</div></div>`;
                });
            });
            html += '</div><div class="skill-category-legend"><div style="font-weight: 600; width: 100%; margin-bottom: 0.5rem;">Proficiency Scale:</div>';
            for (let i = 1; i <= 5; i++) {
                html += `<div class="skill-category-item"><span class="proficiency-dot proficiency-${i}">${i}</span> ${getProficiencyLabel(i)}</div>`;
            }
            html += '</div>';
            return html;
        }

        async function loadAndRenderAgents() {
            const el = document.getElementById('skills-matrix-content');
            try {
                let sessions = allSessions;
                if (!sessions.length) {
                    const r = await fetch(`${API}/sessions`);
                    if (!r.ok) throw new Error('Failed to load');
                    sessions = (await r.json()).nodes || [];
                }
                if (!sessions.length) {
                    el.innerHTML = '<div style="padding: 2rem; color: var(--text-muted);">No agents found</div>';
                    return;
                }
                const { agents, skillProfiles } = analyzeAgentSkills(sessions);
                if (!agents.length) {
                    el.innerHTML = '<div style="padding: 2rem; color: var(--text-muted);">No agents</div>';
                    return;
                }
                el.innerHTML = renderSkillsMatrix(agents, skillProfiles);
            } catch (e) {
                el.innerHTML = `<div style="padding: 2rem; color: red;">Error: ${e.message}</div>`;
            }
        }

        // =====================================================================
        // View Toggle
        // =====================================================================

        function switchView(view) {
            const kanban = document.getElementById('kanban');
            const graph = document.getElementById('graph-container');
            const analytics = document.getElementById('analytics');
            const agents = document.getElementById('agents');
            const sessions = document.getElementById('sessions');
            const buttons = document.querySelectorAll('.view-btn');

            buttons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === view);
            });

            if (view === 'kanban') {
                kanban.classList.add('active');
                graph.classList.remove('active');
                analytics.classList.remove('active');
                agents.classList.remove('active');
                sessions.classList.remove('active');
                renderKanban(allNodes);
            } else if (view === 'graph') {
                kanban.classList.remove('active');
                graph.classList.add('active');
                analytics.classList.remove('active');
                agents.classList.remove('active');
                sessions.classList.remove('active');
                renderGraph(allNodes);
            } else if (view === 'analytics') {
                kanban.classList.remove('active');
                graph.classList.remove('active');
                analytics.classList.add('active');
                agents.classList.remove('active');
                sessions.classList.remove('active');
                ensureAnalyticsLoaded(false);
            } else if (view === 'agents') {
                kanban.classList.remove('active');
                graph.classList.remove('active');
                analytics.classList.remove('active');
                agents.classList.add('active');
                sessions.classList.remove('active');
                loadAndRenderAgents();
            } else if (view === 'sessions') {
                kanban.classList.remove('active');
                graph.classList.remove('active');
                analytics.classList.remove('active');
                agents.classList.remove('active');
                sessions.classList.add('active');
                loadAndRenderSessions();
            }
        }


        // =====================================================================
        // Init
        // =====================================================================

        document.getElementById('panel-close').addEventListener('click', closePanel);
        document.getElementById('panel-overlay').addEventListener('click', closePanel);

        document.querySelectorAll('.view-btn').forEach(btn => {
            btn.addEventListener('click', () => switchView(btn.dataset.view));
        });

        document.getElementById('analytics-refresh').addEventListener('click', () => {
            ensureAnalyticsLoaded(true);
        });

        document.getElementById('analytics-features').addEventListener('click', (e) => {
            const btn = e.target.closest && e.target.closest('button[data-feature]');
            if (!btn) return;
            loadFeatureAnalytics(btn.dataset.feature).catch(err => renderAnalyticsError(err));
        });

        // Session filter event listeners
        document.getElementById('filter-status').addEventListener('change', applySessionFilters);
        document.getElementById('filter-agent').addEventListener('change', applySessionFilters);
        document.getElementById('filter-search').addEventListener('input', applySessionFilters);
        document.getElementById('filter-date-from').addEventListener('change', applySessionFilters);
        document.getElementById('filter-date-to').addEventListener('change', applySessionFilters);
        document.getElementById('filter-clear').addEventListener('click', clearSessionFilters);
        document.getElementById('compare-sessions-btn').addEventListener('click', compareSessions);

        // Session comparison modal
        document.getElementById('comparison-close').addEventListener('click', closeComparison);
        document.getElementById('comparison-overlay').addEventListener('click', closeComparison);

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closePanel();
        });

        loadData().then(async ({ status, nodes }) => {
            await renderKanban(nodes);
            updateKanbanGrid();
        }).catch(err => {
            console.error('Error loading dashboard data:', err);
        });

        function showAllNodes() {
            document.querySelectorAll('.graph-filter-checkbox input').forEach(cb => {
                cb.checked = true;
            });
            graphState.filters = { todo: true, 'in-progress': true, blocked: true, done: true };
            applyGraphFilters();
        }

        function renderGraph(nodes) {
            if (nodes.length === 0) {
                if (visNetwork) visNetwork.destroy();
                visNetwork = null;
                return;
            }

            const { nodes: graphNodes, edges: graphEdges } = buildGraphData(nodes);

            graphState.allNodes = graphNodes;
            graphState.allEdges = graphEdges;

            // Create Vis.js nodes dataset
            const nodesData = new vis.DataSet(graphNodes.map(n => ({
                id: n.id,
                label: wrapText(n.title),
                title: n.title + '\nStatus: ' + n.status,
                color: {
                    background: getNodeColor(n),
                    border: getComputedStyle(document.documentElement).getPropertyValue('--border-strong').trim(),
                    highlight: {
                        background: getNodeColor(n),
                        border: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim()
                    }
                },
                size: getNodeRadius(n),
                font: {
                    size: 12,
                    face: "'JetBrains Mono', monospace",
                    color: 'white',
                    strokeWidth: 0
                },
                physics: true,
                borderWidth: 2,
                status: n.status,
                _collection: n._collection
            })));

            // Create Vis.js edges dataset
            const edgesData = new vis.DataSet(graphEdges.map(e => ({
                from: e.from,
                to: e.to,
                arrows: 'to',
                smooth: { type: 'continuous' },
                color: e.type === 'blocked_by'
                    ? { color: getComputedStyle(document.documentElement).getPropertyValue('--status-blocked').trim(), highlight: getComputedStyle(document.documentElement).getPropertyValue('--status-blocked').trim() }
                    : { color: getComputedStyle(document.documentElement).getPropertyValue('--status-active').trim(), highlight: getComputedStyle(document.documentElement).getPropertyValue('--status-active').trim() },
                dashes: e.type === 'blocked_by' ? [6, 4] : false,
                width: 1.5
            })));

            // Destroy existing network if it exists
            if (visNetwork) {
                visNetwork.destroy();
            }

            // Create new Vis.js network
            const container = document.getElementById('graph-network');
            const data = {
                nodes: nodesData,
                edges: edgesData
            };

            const options = {
                physics: {
                    enabled: true,
                    stabilization: {
                        iterations: 200,
                        fit: true
                    },
                    barnesHut: {
                        gravitationalConstant: -30000,
                        centralGravity: 0.3,
                        springLength: 200,
                        springConstant: 0.04
                    },
                    maxVelocity: 50
                },
                interaction: {
                    navigationButtons: true,
                    keyboard: true,
                    zoomView: true,
                    dragView: true
                },
                nodes: {
                    shape: 'circle',
                    scaling: {
                        min: 10,
                        max: 50
                    }
                }
            };

            visNetwork = new vis.Network(container, data, options);

            // Handle node clicks
            visNetwork.on('click', (params) => {
                if (params.nodes.length > 0) {
                    const nodeId = params.nodes[0];
                    const node = graphState.allNodes.find(n => n.id === nodeId);
                    if (node) {
                        openPanel(node._collection, node.id);
                    }
                }
            });

            // Apply filters after network is initialized
            applyGraphFilters();
        }

        // =====================================================================
        // Agent Skills Analysis
        // =====================================================================

        function analyzeAgentSkills(sessions) {
            const skillProfiles = {};
            const agents = [...new Set(sessions.map(s => s.properties?.agent).filter(Boolean))];
            agents.forEach(agent => {
                skillProfiles[agent] = {Implementation: 0, Analysis: 0, Testing: 0, Documentation: 0, Coordination: 0};
            });
            sessions.forEach(session => {
                const agent = session.properties?.agent;
                if (!agent) return;
                const desc = (session.name || session.id || '').toLowerCase();
                const cnt = session.properties?.event_count || 0;
                if (desc.includes('test') || desc.includes('validate')) skillProfiles[agent].Testing += Math.min(cnt / 10, 2);
                if (desc.includes('implement') || desc.includes('code') || desc.includes('build')) skillProfiles[agent].Implementation += Math.min(cnt / 10, 2);
                if (desc.includes('analyze') || desc.includes('research')) skillProfiles[agent].Analysis += Math.min(cnt / 10, 2);
                if (desc.includes('document') || desc.includes('explain')) skillProfiles[agent].Documentation += Math.min(cnt / 10, 2);
                if (desc.includes('coordinate') || desc.includes('delegate')) skillProfiles[agent].Coordination += Math.min(cnt / 10, 2);
                if (agent.includes('Claude')) {
                    skillProfiles[agent].Analysis = Math.max(skillProfiles[agent].Analysis, 4.5);
                    skillProfiles[agent].Documentation = Math.max(skillProfiles[agent].Documentation, 4);
                }
                if (agent.includes('Codex')) {
                    skillProfiles[agent].Implementation = Math.max(skillProfiles[agent].Implementation, 5);
                    skillProfiles[agent].Testing = Math.max(skillProfiles[agent].Testing, 4);
                }
                if (agent.includes('Orchestrator')) {
                    skillProfiles[agent].Coordination = Math.max(skillProfiles[agent].Coordination, 5);
                    skillProfiles[agent].Analysis = Math.max(skillProfiles[agent].Analysis, 4);
                }
                if (agent.includes('Gemini')) {
                    skillProfiles[agent].Analysis = Math.max(skillProfiles[agent].Analysis, 4.5);
                    skillProfiles[agent].Implementation = Math.max(skillProfiles[agent].Implementation, 3);
                }
            });
            agents.forEach(agent => {
                Object.keys(skillProfiles[agent]).forEach(skill => {
                    skillProfiles[agent][skill] = Math.min(5, Math.max(1, skillProfiles[agent][skill]));
                });
            });
            return { agents, skillProfiles };
        }

        function getProficiencyColor(level) {
            return `proficiency-${Math.round(level)}`;
        }

        function getProficiencyLabel(level) {
            const labels = ['', 'Novice', 'Beginner', 'Intermediate', 'Advanced', 'Expert'];
            return labels[Math.round(level)] || 'Expert';
        }

        function renderSkillsMatrix(agents, skillProfiles) {
            const skills = ['Implementation', 'Analysis', 'Testing', 'Documentation', 'Coordination'];
            let html = '<div class="skills-matrix">';
            html += '<div class="skills-matrix-cell skills-matrix-header-row">AGENT</div>';
            skills.forEach(skill => html += `<div class="skills-matrix-cell skills-matrix-header-row">${skill}</div>`);
            agents.forEach(agent => {
                html += `<div class="skills-matrix-cell skills-matrix-agent-name">${agent}</div>`;
                skills.forEach(skill => {
                    const level = skillProfiles[agent][skill];
                    const rnd = Math.round(level);
                    html += `<div class="skills-matrix-cell"><div class="proficiency-dot ${getProficiencyColor(level)}" title="${getProficiencyLabel(level)} (${rnd}/5)">${rnd}</div></div>`;
                });
            });
            html += '</div><div class="skill-category-legend"><div style="font-weight: 600; width: 100%; margin-bottom: 0.5rem;">Proficiency Scale:</div>';
            for (let i = 1; i <= 5; i++) {
                html += `<div class="skill-category-item"><span class="proficiency-dot proficiency-${i}">${i}</span> ${getProficiencyLabel(i)}</div>`;
            }
            html += '</div>';
            return html;
        }

        async function loadAndRenderAgents() {
            const el = document.getElementById('skills-matrix-content');
            try {
                let sessions = allSessions;
                if (!sessions.length) {
                    const r = await fetch(`${API}/sessions`);
                    if (!r.ok) throw new Error('Failed to load');
                    sessions = (await r.json()).nodes || [];
                }
                if (!sessions.length) {
                    el.innerHTML = '<div style="padding: 2rem; color: var(--text-muted);">No agents found</div>';
                    return;
                }
                const { agents, skillProfiles } = analyzeAgentSkills(sessions);
                if (!agents.length) {
                    el.innerHTML = '<div style="padding: 2rem; color: var(--text-muted);">No agents</div>';
                    return;
                }
                el.innerHTML = renderSkillsMatrix(agents, skillProfiles);
            } catch (e) {
                el.innerHTML = `<div style="padding: 2rem; color: red;">Error: ${e.message}</div>`;
            }
        }

        // =====================================================================
        // View Toggle
        // =====================================================================

        function switchView(view) {
            const kanban = document.getElementById('kanban');
            const graph = document.getElementById('graph-container');
            const analytics = document.getElementById('analytics');
            const agents = document.getElementById('agents');
            const sessions = document.getElementById('sessions');
            const buttons = document.querySelectorAll('.view-btn');

            buttons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === view);
            });

            if (view === 'kanban') {
                kanban.classList.add('active');
                graph.classList.remove('active');
                analytics.classList.remove('active');
                agents.classList.remove('active');
                sessions.classList.remove('active');
                renderKanban(allNodes);
            } else if (view === 'graph') {
                kanban.classList.remove('active');
                graph.classList.add('active');
                analytics.classList.remove('active');
                agents.classList.remove('active');
                sessions.classList.remove('active');
                renderGraph(allNodes);
            } else if (view === 'analytics') {
                kanban.classList.remove('active');
                graph.classList.remove('active');
                analytics.classList.add('active');
                agents.classList.remove('active');
                sessions.classList.remove('active');
                ensureAnalyticsLoaded(false);
            } else if (view === 'agents') {
                kanban.classList.remove('active');
                graph.classList.remove('active');
                analytics.classList.remove('active');
                agents.classList.add('active');
                sessions.classList.remove('active');
                loadAndRenderAgents();
            } else if (view === 'sessions') {
                kanban.classList.remove('active');
                graph.classList.remove('active');
                analytics.classList.remove('active');
                agents.classList.remove('active');
                sessions.classList.add('active');
                loadAndRenderSessions();
            }
        }


        // =====================================================================
        // Init
        // =====================================================================

        document.getElementById('panel-close').addEventListener('click', closePanel);
        document.getElementById('panel-overlay').addEventListener('click', closePanel);

        document.querySelectorAll('.view-btn').forEach(btn => {
            btn.addEventListener('click', () => switchView(btn.dataset.view));
        });

        document.getElementById('analytics-refresh').addEventListener('click', () => {
            ensureAnalyticsLoaded(true);
        });

        document.getElementById('analytics-features').addEventListener('click', (e) => {
            const btn = e.target.closest && e.target.closest('button[data-feature]');
            if (!btn) return;
            loadFeatureAnalytics(btn.dataset.feature).catch(err => renderAnalyticsError(err));
        });

        // Session filter event listeners
        document.getElementById('filter-status').addEventListener('change', applySessionFilters);
        document.getElementById('filter-agent').addEventListener('change', applySessionFilters);
        document.getElementById('filter-search').addEventListener('input', applySessionFilters);
        document.getElementById('filter-date-from').addEventListener('change', applySessionFilters);
        document.getElementById('filter-date-to').addEventListener('change', applySessionFilters);
        document.getElementById('filter-clear').addEventListener('click', clearSessionFilters);
        document.getElementById('compare-sessions-btn').addEventListener('click', compareSessions);

        // Session comparison modal
        document.getElementById('comparison-close').addEventListener('click', closeComparison);
        document.getElementById('comparison-overlay').addEventListener('click', closeComparison);

        // Graph filter event listeners
        document.querySelectorAll('.graph-filter-checkbox input').forEach(cb => {
            cb.addEventListener('change', applyGraphFilters);
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closePanel();
        });

        loadData().then(async ({ status, nodes }) => {
            await renderKanban(nodes);
            updateKanbanGrid();
        }).catch(err => {
            console.error('Error loading data:', err);
        });

        // =====================================================================
        // Spec/Plan Modal Viewer
        // =====================================================================

        let currentModalTrackId = null;
        let currentModalType = null; // 'spec' or 'plan'

        function openSpecPlanModal(trackId, type, trackTitle) {
            currentModalTrackId = trackId;
            currentModalType = type;

            const modal = document.getElementById('spec-plan-modal');
            const breadcrumbTrack = document.getElementById('modal-breadcrumb-track');
            const breadcrumbType = document.getElementById('modal-breadcrumb-type');
            const trackBtn = document.getElementById('modal-toggle-track');
            const specBtn = document.getElementById('modal-toggle-spec');
            const planBtn = document.getElementById('modal-toggle-plan');
            const toggleContainer = specBtn.parentElement;

            // Update breadcrumb
            breadcrumbTrack.textContent = trackTitle || trackId;
            breadcrumbType.textContent = type.toUpperCase();

            // Always show toggle buttons
            toggleContainer.style.display = 'flex';

            // Remove active from all buttons
            trackBtn.classList.remove('active');
            specBtn.classList.remove('active');
            planBtn.classList.remove('active');

            // Set active based on type
            if (type === 'track') {
                trackBtn.classList.add('active');
            } else if (type === 'spec') {
                specBtn.classList.add('active');
            } else if (type === 'plan') {
                planBtn.classList.add('active');
            }

            // Show modal with animation
            modal.style.display = 'flex';
            setTimeout(() => modal.classList.add('active'), 10);

            // Load content
            loadSpecPlanContent(trackId, type);
        }

        function closeSpecPlanModal() {
            const modal = document.getElementById('spec-plan-modal');
            modal.classList.remove('active');
            setTimeout(() => {
                modal.style.display = 'none';
                currentModalTrackId = null;
                currentModalType = null;
            }, 400); // Match CSS transition duration
        }

        function toggleSpecPlan(type) {
            if (type === currentModalType || !currentModalTrackId) return;

            currentModalType = type;

            // Update toggle buttons
            const trackBtn = document.getElementById('modal-toggle-track');
            const specBtn = document.getElementById('modal-toggle-spec');
            const planBtn = document.getElementById('modal-toggle-plan');

            // Remove active from all
            trackBtn.classList.remove('active');
            specBtn.classList.remove('active');
            planBtn.classList.remove('active');

            // Add active to current
            if (type === 'track') {
                trackBtn.classList.add('active');
            } else if (type === 'spec') {
                specBtn.classList.add('active');
            } else if (type === 'plan') {
                planBtn.classList.add('active');
            }

            // Update breadcrumb
            document.getElementById('modal-breadcrumb-type').textContent = type.toUpperCase();

            // Load new content
            loadSpecPlanContent(currentModalTrackId, type);
        }

        async function loadSpecPlanContent(trackId, type) {
            const contentEl = document.getElementById('spec-plan-content');
            contentEl.innerHTML = '<div class="spec-plan-loading">Loading...</div>';

            try {
                // Determine the filename based on type
                const filename = type === 'track' ? 'index.html' : `${type}.html`;
                const url = `.htmlgraph/tracks/${trackId}/${filename}`;
                const response = await fetch(url);

                if (!response.ok) {
                    const typeName = type === 'spec' ? 'Specification' : type === 'plan' ? 'Plan' : 'Track';
                    throw new Error(`${typeName} not found`);
                }

                const html = await response.text();

                // Parse HTML and extract the content
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');

                // Get the article content (or body if no article)
                const article = doc.querySelector('article') || doc.querySelector('body');

                if (article) {
                    contentEl.innerHTML = article.innerHTML;

                    // Re-initialize any interactive elements (collapsible sections, etc.)
                    initializeModalInteractivity();
                } else {
                    contentEl.innerHTML = '<div class="spec-plan-error">Failed to load content</div>';
                }

            } catch (err) {
                contentEl.innerHTML = `<div class="spec-plan-error">Error: ${err.message}</div>`;
            }
        }

        function initializeModalInteractivity() {
            // Intercept clicks on spec/plan links in track content
            const specPlanLinks = document.querySelectorAll('.spec-plan-content nav[data-track-components] a');
            specPlanLinks.forEach(link => {
                link.addEventListener('click', function(e) {
                    const href = this.getAttribute('href');
                    if (href === '#' || href === 'spec.html' || href === 'plan.html') {
                        e.preventDefault();
                        // Determine type from link text
                        const text = this.textContent.toLowerCase();
                        if (text.includes('spec')) {
                            toggleSpecPlan('spec');
                        } else if (text.includes('plan')) {
                            toggleSpecPlan('plan');
                        }
                    }
                });
            });

            // Re-initialize collapsible phases if they exist
            const phaseHeaders = document.querySelectorAll('.spec-plan-content .phase-header');
            phaseHeaders.forEach(header => {
                header.style.cursor = 'pointer';
                header.addEventListener('click', function() {
                    const phaseContent = this.nextElementSibling;
                    if (phaseContent && phaseContent.classList.contains('phase-content')) {
                        phaseContent.classList.toggle('collapsed');
                    }
                });
            });

            // Re-initialize search/filter if it exists
            const searchInput = document.querySelector('.spec-plan-content input[type="text"]');
            if (searchInput) {
                searchInput.addEventListener('input', function(e) {
                    // Implement search logic here if needed
                    console.log('Search:', e.target.value);
                });
            }
        }

        // Keyboard shortcut to close modal (Escape key)
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && currentModalTrackId) {
                closeSpecPlanModal();
            }
        });

        // Convert UTC timestamps to local timezone
        function convertTimestampsToLocal() {
            const timestampElements = document.querySelectorAll('[data-utc-time]');
            timestampElements.forEach(element => {
                const utcTime = element.getAttribute('data-utc-time');
                if (utcTime) {
                    try {
                        // Parse ISO 8601 UTC time - convert naive datetime to UTC format
                        // Input: "2026-01-06 18:01:19"  "2026-01-06T18:01:19Z"
                        const date = new Date(utcTime.replace(' ', 'T') + 'Z');
                        // Convert to local timezone using Intl API for best compatibility
                        const localTime = new Intl.DateTimeFormat('en-US', {
                            year: 'numeric',
                            month: '2-digit',
                            day: '2-digit',
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit',
                            hour12: false,
                            timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                        }).format(date);
                        // Replace the displayed timestamp with local time
                        element.textContent = localTime;
                        // Add title attribute to show full ISO format on hover
                        element.setAttribute('title', `UTC: ${utcTime} | Local: ${localTime}`);
                    } catch (err) {
                        console.warn('Failed to convert timestamp:', utcTime, err);
                    }
                }
            });
        }

        // Convert timestamps on page load
        document.addEventListener('DOMContentLoaded', convertTimestampsToLocal);

        // Also convert timestamps when new content is dynamically loaded (e.g., via HTMX)
        if (typeof htmx !== 'undefined') {
            document.addEventListener('htmx:afterSwap', convertTimestampsToLocal);
        }

        // Convert timestamps via WebSocket updates
        const originalWebSocketOpen = WebSocket.prototype.open;
        if (originalWebSocketOpen) {
            // Re-convert after WebSocket message arrives
            document.addEventListener('ws:update', convertTimestampsToLocal);
        }
    </script>

    <!-- Spec/Plan Modal -->
    <div id="spec-plan-modal" class="spec-plan-modal">
        <div class="spec-plan-backdrop" onclick="closeSpecPlanModal()"></div>
        <div class="spec-plan-panel">
            <div class="spec-plan-header">
                <div class="spec-plan-breadcrumb">
                    <a href="#" onclick="closeSpecPlanModal(); return false;">TRACKS</a>
                    <span class="separator"></span>
                    <span id="modal-breadcrumb-track">...</span>
                    <span class="separator"></span>
                    <span class="current" id="modal-breadcrumb-type">SPEC</span>
                </div>
                <div class="spec-plan-controls">
                    <div class="spec-plan-toggle">
                        <button id="modal-toggle-track" onclick="toggleSpecPlan('track')"> TRACK</button>
                        <button id="modal-toggle-spec" onclick="toggleSpecPlan('spec')"> SPEC</button>
                        <button id="modal-toggle-plan" onclick="toggleSpecPlan('plan')"> PLAN</button>
                    </div>
                    <button class="spec-plan-close" onclick="closeSpecPlanModal()" title="Close (Esc)">
                        
                    </button>
                </div>
            </div>
            <div id="spec-plan-content" class="spec-plan-content">
                <div class="spec-plan-loading">Loading...</div>
            </div>
        </div>
    </div>
</body>
</html>
