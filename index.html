<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }} - HtmlGraph</title>
    <script src="/static/htmx.min.js"></script>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body class="dark-theme">
    <div class="dashboard-container">
        <!-- Header -->
        <header class="dashboard-header">
            <div class="header-content">
                <h1 class="logo">
                    <span class="logo-icon">âš¡</span>
                    HtmlGraph Dashboard
                </h1>
                <div class="header-stats">
                    <div class="stat-badge">
                        <span class="stat-label">Events</span>
                        <span class="stat-value" id="event-count">0</span>
                    </div>
                    <div class="stat-badge">
                        <span class="stat-label">Agents</span>
                        <span class="stat-value" id="agent-count">0</span>
                    </div>
                    <div class="stat-badge">
                        <span class="stat-label">Sessions</span>
                        <span class="stat-value" id="session-count">0</span>
                    </div>
                </div>
            </div>
        </header>

        <!-- Navigation Tabs -->
        <nav class="tabs-navigation">
            <button class="tab-button active"
                    hx-get="/views/activity-feed"
                    hx-target="#content-area"
                    hx-trigger="click"
                    data-tab="activity">
                <span class="tab-icon">ðŸ“‹</span>
                Activity Feed
            </button>
            <button class="tab-button"
                    hx-get="/views/orchestration"
                    hx-target="#content-area"
                    hx-trigger="click"
                    data-tab="orchestration">
                <span class="tab-icon">ðŸ”—</span>
                Orchestration
            </button>
            <button class="tab-button"
                    hx-get="/views/work-items"
                    hx-target="#content-area"
                    hx-trigger="click"
                    data-tab="work-items">
                <span class="tab-icon">ðŸŽ¯</span>
                Work Items
            </button>
            <button class="tab-button"
                    hx-get="/views/agents"
                    hx-target="#content-area"
                    hx-trigger="click"
                    data-tab="agents">
                <span class="tab-icon">ðŸ¤–</span>
                Agents
            </button>
            <button class="tab-button"
                    hx-get="/views/metrics"
                    hx-target="#content-area"
                    hx-trigger="click"
                    data-tab="metrics">
                <span class="tab-icon">ðŸ“Š</span>
                Metrics
            </button>
            <button class="tab-button"
                    hx-get="/views/spawners"
                    hx-target="#content-area"
                    hx-trigger="click"
                    data-tab="spawners">
                <span class="tab-icon">ðŸš€</span>
                Spawners
            </button>
        </nav>

        <!-- Content Area -->
        <main class="content-area" id="content-area">
            <div class="loading-indicator">
                <div class="spinner"></div>
                <p>Loading dashboard...</p>
            </div>
        </main>
    </div>

    <!-- WebSocket for live updates -->
    <script>
        let eventCount = 0;
        let agentSet = new Set();
        let sessionCount = 0;
        let processedEventIds = new Set();

        // Load initial stats from server
        async function loadInitialStats() {
            try {
                const response = await fetch('/api/initial-stats');
                const data = await response.json();

                // Update header stats
                eventCount = data.total_events || 0;
                sessionCount = data.total_sessions || 0;

                // Update agent set from database
                if (data.agents) {
                    data.agents.forEach(agent => agentSet.add(agent));
                }

                // Update UI
                document.getElementById('event-count').textContent = eventCount;
                document.getElementById('agent-count').textContent = agentSet.size;
                document.getElementById('session-count').textContent = sessionCount;

                console.log('Initial stats loaded:', data);
            } catch (error) {
                console.error('Failed to load initial stats:', error);
            }
        }

        // Initialize dashboard on load
        document.addEventListener('DOMContentLoaded', function() {
            // Load initial stats
            loadInitialStats();

            // Load initial activity feed
            htmx.ajax('GET', '/views/activity-feed', {target: '#content-area'});

            // Connect WebSocket for real-time updates
            connectWebSocket();
        });

        // Convert timestamps after HTMX loads Activity Feed
        document.body.addEventListener('htmx:afterSettle', function(evt) {
            if (evt.detail.target.id === 'content-area') {
                // Activity Feed has been loaded, convert timestamps to local timezone
                if (typeof convertTimestampsToLocal === 'function') {
                    convertTimestampsToLocal();
                }
            }
        });

        function connectWebSocket() {
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const ws = new WebSocket(wsProtocol + '//' + window.location.host + '/ws/events');

            ws.onopen = function(event) {
                console.log('WebSocket connected for real-time events');
                updateWebSocketStatus(true);
            };

            ws.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    console.log('[WebSocket] Received message type:', data.type);

                    if (data.type === 'event') {
                        // Prevent duplicate event insertions
                        if (processedEventIds.has(data.event_id)) {
                            return;
                        }
                        processedEventIds.add(data.event_id);

                        // Update stats
                        eventCount++;
                        if (data.agent_id) {
                            agentSet.add(data.agent_id);
                        }

                        // Update header
                        document.getElementById('event-count').textContent = eventCount;
                        document.getElementById('agent-count').textContent = agentSet.size;

                        // Add animation class to event count badge
                        const badge = document.getElementById('event-count').parentElement;
                        badge.classList.add('pulse');
                        setTimeout(() => badge.classList.remove('pulse'), 500);

                        // Insert new event into Activity Feed if visible
                        insertNewEventIntoActivityFeed(data);
                    }
                    // Handle live spawner events for real-time streaming
                    else if (data.type === 'spawner_event') {
                        console.log('[WebSocket] spawner_event received:', data.event_type, data.spawner_type, 'handler exists:', typeof window.handleSpawnerEvent === 'function');
                        // Delegate to activity-feed.html handler if available
                        if (typeof window.handleSpawnerEvent === 'function') {
                            window.handleSpawnerEvent(data);
                        } else {
                            console.warn('[WebSocket] handleSpawnerEvent not available, spawner event dropped:', data.event_type, data.spawner_type);
                        }
                    }
                } catch (e) {
                    console.error('WebSocket message error:', e);
                }
            };

            ws.onerror = function(event) {
                console.error('WebSocket error:', event);
                updateWebSocketStatus(false);
            };

            ws.onclose = function(event) {
                console.log('WebSocket disconnected, reconnecting in 3s...');
                updateWebSocketStatus(false);
                setTimeout(connectWebSocket, 3000);
            };
        }

        function updateWebSocketStatus(isConnected) {
            // Update live update indicator in activity feed
            const indicator = document.querySelector('.auto-refresh-indicator');
            if (indicator) {
                const dot = indicator.querySelector('.refresh-dot');
                if (isConnected) {
                    dot.style.backgroundColor = '#10b981';
                    indicator.style.opacity = '1';
                } else {
                    dot.style.backgroundColor = '#ef4444';
                    indicator.style.opacity = '0.6';
                }
            }
        }

        function insertNewEventIntoActivityFeed(eventData) {
            // Check if activity feed is currently displayed
            const activityFeed = document.querySelector('.activity-feed-view');
            if (!activityFeed) {
                // Activity feed not visible, skip insertion
                return;
            }

            const conversationFeed = activityFeed.querySelector('.conversation-feed');
            if (!conversationFeed) {
                return;
            }

            // Check if there's an empty state message
            const emptyState = conversationFeed.querySelector('.empty-state');
            if (emptyState) {
                // Replace empty state with conversation turns list
                emptyState.remove();
                const turnsList = document.createElement('div');
                turnsList.className = 'conversation-turns-list';
                conversationFeed.appendChild(turnsList);
            }

            // Get or create conversation turns list
            let turnsList = conversationFeed.querySelector('.conversation-turns-list');
            if (!turnsList) {
                turnsList = document.createElement('div');
                turnsList.className = 'conversation-turns-list';
                conversationFeed.appendChild(turnsList);
            }

            // Handle UserQuery events - create new conversation turn
            if (eventData.tool_name === 'UserQuery') {
                const turnHTML = createConversationTurnHTML(eventData);
                // Insert at top (newest first)
                turnsList.insertAdjacentHTML('afterbegin', turnHTML);

                // Highlight the new turn
                const newTurn = turnsList.querySelector(`[data-turn-id="${eventData.event_id}"]`);
                if (newTurn) {
                    highlightElement(newTurn.querySelector('.userquery-parent'));
                }

                // Convert timestamps
                if (typeof convertTimestampsToLocal === 'function') {
                    convertTimestampsToLocal();
                }
                return;
            }

            // Handle child events - insert into appropriate conversation turn
            if (eventData.parent_event_id) {
                // Try to find the parent event's container
                const parentChildRow = document.querySelector(`[data-event-id="${eventData.parent_event_id}"]`);

                if (parentChildRow) {
                    // Parent exists - insert as nested child
                    const childHTML = createChildEventHTML(eventData, 1); // Start at depth 1

                    // Check if parent already has a nested children container
                    let childrenContainer = document.getElementById(`children-child-${eventData.parent_event_id}`);

                    if (!childrenContainer) {
                        // Parent doesn't have children container yet - create one
                        childrenContainer = document.createElement('div');
                        childrenContainer.className = 'child-children collapsed';
                        childrenContainer.id = `children-child-${eventData.parent_event_id}`;
                        childrenContainer.setAttribute('data-parent-event', eventData.parent_event_id);
                        childrenContainer.setAttribute('data-depth', '1');

                        // Insert after the parent row
                        parentChildRow.insertAdjacentElement('afterend', childrenContainer);

                        // Update parent row to show it has nested children
                        parentChildRow.classList.add('has-nested-children');
                        parentChildRow.setAttribute('onclick', `toggleChildEvent('${eventData.parent_event_id}', event)`);

                        // Add expand toggle if not present
                        const existingToggle = parentChildRow.querySelector('.expand-toggle-child');
                        if (!existingToggle) {
                            const treeConnector = parentChildRow.querySelector('.tree-connector');
                            if (treeConnector) {
                                const toggle = document.createElement('span');
                                toggle.className = 'expand-toggle-child';
                                toggle.id = `toggle-child-${eventData.parent_event_id}`;
                                toggle.textContent = 'â–¶';
                                treeConnector.replaceWith(toggle);
                            }
                        }

                        // Add nested count badge
                        const existingBadge = parentChildRow.querySelector('.nested-count-badge');
                        if (!existingBadge) {
                            const badge = document.createElement('span');
                            badge.className = 'nested-count-badge';
                            badge.title = '1 nested events';
                            badge.textContent = '1';
                            // Insert before duration span
                            const durationSpan = parentChildRow.querySelector('.child-duration');
                            if (durationSpan) {
                                durationSpan.insertAdjacentElement('beforebegin', badge);
                            }
                        }
                    } else {
                        // Update nested count badge
                        const badge = parentChildRow.querySelector('.nested-count-badge');
                        if (badge) {
                            const currentCount = parseInt(badge.textContent) || 0;
                            const newCount = currentCount + 1;
                            badge.textContent = newCount;
                            badge.title = `${newCount} nested events`;
                        }
                    }

                    // Insert child into container (newest first)
                    childrenContainer.insertAdjacentHTML('afterbegin', childHTML);

                    // Highlight the new child
                    const newChild = childrenContainer.querySelector(`[data-event-id="${eventData.event_id}"]`);
                    if (newChild) {
                        highlightElement(newChild);
                    }

                    return;
                }

                // Parent not found - try to find the conversation turn by checking UserQuery parent
                const turnContainer = findConversationTurnForEvent(eventData.parent_event_id);

                if (turnContainer) {
                    // Insert into conversation turn's children
                    const turnChildrenContainer = turnContainer.querySelector('.turn-children');
                    if (turnChildrenContainer) {
                        const childHTML = createChildEventHTML(eventData, 0); // Top-level child
                        turnChildrenContainer.insertAdjacentHTML('afterbegin', childHTML);

                        // Remove "no children" message if present
                        const noChildrenMsg = turnChildrenContainer.querySelector('.no-children-message');
                        if (noChildrenMsg) {
                            noChildrenMsg.remove();
                        }

                        // Update turn stats
                        updateTurnStats(turnContainer);

                        // Highlight the new child
                        const newChild = turnChildrenContainer.querySelector(`[data-event-id="${eventData.event_id}"]`);
                        if (newChild) {
                            highlightElement(newChild);
                        }

                        return;
                    }
                }

                // If we still can't find the parent, create an orphaned event placeholder
                // This will be re-parented when the actual parent arrives
                console.warn('[Activity Feed] Parent not found for event, creating orphan:', eventData.event_id, 'parent:', eventData.parent_event_id);
                storeOrphanedEvent(eventData);
            }

            // Convert timestamps
            if (typeof convertTimestampsToLocal === 'function') {
                convertTimestampsToLocal();
            }

            // Keep only last 50 conversation turns to prevent memory issues
            const allTurns = turnsList.querySelectorAll('.conversation-turn');
            if (allTurns.length > 50) {
                const itemsToRemove = allTurns.length - 50;
                for (let i = 0; i < itemsToRemove; i++) {
                    allTurns[allTurns.length - 1 - i].remove();
                }
            }
        }

        // Store for orphaned events (children that arrive before their parents)
        const orphanedEvents = new Map();

        function storeOrphanedEvent(eventData) {
            const parentId = eventData.parent_event_id;
            if (!orphanedEvents.has(parentId)) {
                orphanedEvents.set(parentId, []);
            }
            orphanedEvents.get(parentId).push(eventData);
        }

        function adoptOrphanedChildren(parentEventId) {
            if (!orphanedEvents.has(parentEventId)) {
                return;
            }

            const orphans = orphanedEvents.get(parentEventId);
            orphanedEvents.delete(parentEventId);

            // Re-insert each orphan now that parent exists
            for (const orphan of orphans) {
                insertNewEventIntoActivityFeed(orphan);
            }
        }

        function findConversationTurnForEvent(eventId) {
            // Search all conversation turns for an event with this ID
            const turns = document.querySelectorAll('.conversation-turn');
            for (const turn of turns) {
                const turnId = turn.getAttribute('data-turn-id');
                if (turnId === eventId) {
                    return turn;
                }
                // Also check if eventId is within this turn's children
                const childEvent = turn.querySelector(`[data-event-id="${eventId}"]`);
                if (childEvent) {
                    return turn;
                }
            }
            return null;
        }

        function createConversationTurnHTML(eventData) {
            const prompt = eventData.input_summary || 'No prompt';
            const promptPreview = prompt.length > 100 ? prompt.substring(0, 100) + '...' : prompt;
            const timestamp = eventData.timestamp || '';

            return `
                <div class="conversation-turn"
                     data-turn-id="${escapeHtml(eventData.event_id)}"
                     data-spawner-type="direct"
                     data-agent="${escapeHtml(eventData.agent_id || 'unknown')}">
                    <!-- User Query Parent Row (Clickable) -->
                    <div class="userquery-parent"
                         onclick="toggleConversationTurn('${escapeHtml(eventData.event_id)}')"
                         data-turn-id="${escapeHtml(eventData.event_id)}">

                        <!-- Expand/Collapse Toggle -->
                        <span class="expand-toggle-turn" id="toggle-${escapeHtml(eventData.event_id)}">â–¶</span>

                        <!-- User Prompt Text -->
                        <div class="prompt-section">
                            <span class="prompt-text" title="${escapeHtml(prompt)}">
                                ${escapeHtml(promptPreview)}
                            </span>
                        </div>

                        <!-- Stats Badges -->
                        <div class="turn-stats">
                            <span class="stat-badge tool-count" title="Tool calls">0</span>
                            <span class="stat-badge duration" title="Total duration">0.00s</span>
                        </div>

                        <!-- Timestamp -->
                        <div class="turn-timestamp">
                            <span data-utc-time="${escapeHtml(timestamp)}">${escapeHtml(timestamp)}</span>
                        </div>
                    </div>

                    <!-- Child Events Container (Hidden by default) -->
                    <div class="turn-children collapsed" id="children-${escapeHtml(eventData.event_id)}">
                        <div class="no-children-message">
                            <span class="tree-connector">â””â”€</span>
                            <span class="text-muted">No child events yet</span>
                        </div>
                    </div>
                </div>
            `;
        }

        function createChildEventHTML(eventData, depth = 0) {
            const summary = eventData.input_summary || '';
            const summaryPreview = summary.length > 80 ? summary.substring(0, 80) + '...' : summary;
            const duration = eventData.execution_duration_seconds || 0;
            const timestamp = eventData.timestamp || '';
            const agent = eventData.agent_id || 'unknown';
            const model = eventData.model || null;
            const toolName = eventData.tool_name || 'Unknown';
            const featureId = eventData.feature_id || null;

            // Determine if this is a spawner event
            const spawnerType = eventData.spawner_type || null;
            const spawnedAgent = eventData.spawned_agent || null;
            const subagentType = eventData.subagent_type || null;

            let agentBadgeHTML = '';
            if (depth === 0) {
                // Only show agent badge on top-level events
                if (spawnerType) {
                    agentBadgeHTML = `
                        <span class="child-agent-badge agent-${escapeHtml(agent.toLowerCase().replace(/\s+/g, '-'))}">
                            ${escapeHtml(agent)}
                            ${model ? `<span class="model-indicator">${escapeHtml(model)}</span>` : ''}
                        </span>
                        <span class="delegation-arrow">â†’</span>
                        <span class="spawner-badge spawner-${escapeHtml(spawnerType.toLowerCase())}">
                            ${escapeHtml(spawnedAgent || subagentType || spawnerType)}
                        </span>
                    `;
                } else {
                    agentBadgeHTML = `
                        <span class="child-agent-badge agent-${escapeHtml(agent.toLowerCase().replace(/\s+/g, '-'))}">
                            ${escapeHtml(agent)}
                            ${model ? `<span class="model-indicator">${escapeHtml(model)}</span>` : ''}
                        </span>
                    `;
                }
            }

            const featureBadgeHTML = featureId ? `
                <span class="child-feature-badge" title="Linked to ${escapeHtml(featureId)}">
                    #${escapeHtml(featureId.substring(0, 8))}
                </span>
            ` : '';

            return `
                <div class="child-event-row depth-${depth}"
                     data-event-id="${escapeHtml(eventData.event_id)}"
                     data-depth="${depth}">

                    <!-- Tree Connector (no toggle initially) -->
                    <span class="tree-connector">â”œâ”€</span>

                    <!-- Tool Name -->
                    <span class="child-tool-name">${escapeHtml(toolName)}</span>

                    <!-- Summary/Input -->
                    <span class="child-summary" title="${escapeHtml(summary)}">
                        ${escapeHtml(summaryPreview)}
                    </span>

                    <!-- Agent Badge -->
                    ${agentBadgeHTML}

                    <!-- Feature Badge -->
                    ${featureBadgeHTML}

                    <!-- Duration -->
                    <span class="child-duration">
                        ${duration.toFixed(2)}s
                    </span>

                    <!-- Timestamp -->
                    <span class="child-timestamp">
                        <span data-utc-time="${escapeHtml(timestamp)}">${escapeHtml(timestamp)}</span>
                    </span>
                </div>
            `;
        }

        function updateTurnStats(turnContainer) {
            // Count all child events recursively
            const allChildren = turnContainer.querySelectorAll('.child-event-row');
            const toolCount = allChildren.length;

            // Sum all durations
            let totalDuration = 0;
            allChildren.forEach(child => {
                const durationSpan = child.querySelector('.child-duration');
                if (durationSpan) {
                    const duration = parseFloat(durationSpan.textContent) || 0;
                    totalDuration += duration;
                }
            });

            // Update badges
            const toolBadge = turnContainer.querySelector('.stat-badge.tool-count');
            if (toolBadge) {
                toolBadge.textContent = toolCount;
            }

            const durationBadge = turnContainer.querySelector('.stat-badge.duration');
            if (durationBadge) {
                durationBadge.textContent = totalDuration.toFixed(2) + 's';
            }
        }

        function highlightElement(element) {
            if (element) {
                element.classList.add('new-event-highlight');
                // Remove highlight after animation
                setTimeout(() => {
                    element.classList.remove('new-event-highlight');
                }, 2000);
            }
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Convert UTC timestamps to local timezone
        function convertTimestampsToLocal() {
            const timestampElements = document.querySelectorAll('[data-utc-time]');
            console.log('convertTimestampsToLocal() called, found', timestampElements.length, 'timestamps to convert');
            timestampElements.forEach(element => {
                const utcTime = element.getAttribute('data-utc-time');
                if (utcTime) {
                    try {
                        // Parse ISO 8601 UTC time - convert naive datetime to UTC format
                        // Input: "2026-01-06 18:01:19" â†’ "2026-01-06T18:01:19Z"
                        const date = new Date(utcTime.replace(' ', 'T') + 'Z');
                        // Convert to local timezone using Intl API for best compatibility
                        const localTime = new Intl.DateTimeFormat('en-US', {
                            year: 'numeric',
                            month: '2-digit',
                            day: '2-digit',
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit',
                            hour12: false,
                            timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                        }).format(date);
                        // Replace the displayed timestamp with local time
                        element.textContent = localTime;
                        // Add title attribute to show full ISO format on hover
                        element.setAttribute('title', `UTC: ${utcTime} | Local: ${localTime}`);
                    } catch (err) {
                        console.warn('Failed to convert timestamp:', utcTime, err);
                    }
                }
            });
        }

        // Handle tab switching
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', function() {
                // Update active state
                document.querySelectorAll('.tab-button').forEach(b => {
                    b.classList.remove('active');
                });
                this.classList.add('active');
            });
        });

        // ============================================
        // Jaeger-Style Trace Interactivity Functions
        // (Must be global for HTMX-loaded partials)
        // ============================================

        // Toggle expand/collapse with animation
        function toggleTrace(id, event) {
            if (event) event.stopPropagation();

            const parentRow = document.querySelector(`[data-id="${id}"]`);
            const children = document.querySelectorAll(`[data-parent="${id}"]`);
            const toggle = document.querySelector(`[data-id="${id}"] .expand-toggle`);

            children.forEach(child => {
                child.classList.toggle('collapsed');
            });

            if (toggle) {
                toggle.classList.toggle('expanded');
            }

            // Toggle expanded class on parent row for visual styling
            if (parentRow) {
                parentRow.classList.toggle('expanded');
            }

            // Update breadcrumbs if drilling into a trace
            updateBreadcrumbs(id);
        }

        // Highlight ancestor path on hover (Jaeger pattern)
        function highlightAncestors(row) {
            clearAncestorHighlight();

            let parentId = row.dataset.parent;
            while (parentId) {
                const parent = document.querySelector(`[data-id="${parentId}"]`);
                if (parent) {
                    parent.classList.add('ancestor-highlight');
                    parentId = parent.dataset.parent;
                } else {
                    break;
                }
            }
        }

        // Clear all ancestor highlights
        function clearAncestorHighlight() {
            document.querySelectorAll('.ancestor-highlight').forEach(el => {
                el.classList.remove('ancestor-highlight');
            });
        }

        // Expand all traces
        function expandAllTraces() {
            document.querySelectorAll('.child-row').forEach(child => {
                child.classList.remove('collapsed');
            });
            document.querySelectorAll('.expand-toggle').forEach(toggle => {
                toggle.classList.add('expanded');
            });
            document.querySelectorAll('.parent-row.has-children').forEach(parent => {
                parent.classList.add('expanded');
            });
            // Show breadcrumbs when all expanded
            const breadcrumbs = document.getElementById('trace-breadcrumbs');
            if (breadcrumbs) breadcrumbs.style.display = 'flex';
        }

        // Collapse all traces
        function collapseAllTraces() {
            document.querySelectorAll('.child-row').forEach(child => {
                child.classList.add('collapsed');
            });
            document.querySelectorAll('.expand-toggle').forEach(toggle => {
                toggle.classList.remove('expanded');
            });
            document.querySelectorAll('.parent-row.has-children').forEach(parent => {
                parent.classList.remove('expanded');
            });
            // Hide breadcrumbs when all collapsed
            const breadcrumbs = document.getElementById('trace-breadcrumbs');
            if (breadcrumbs) breadcrumbs.style.display = 'none';
        }

        // Breadcrumb management
        let breadcrumbStack = ['root'];

        function updateBreadcrumbs(id) {
            const breadcrumbsContainer = document.getElementById('trace-breadcrumbs');
            if (!breadcrumbsContainer) return;

            const row = document.querySelector(`[data-id="${id}"]`);
            if (!row) return;

            // Only show breadcrumbs when we have nested navigation
            const depth = parseInt(row.dataset.depth || '0');
            if (depth > 0 || breadcrumbStack.length > 1) {
                breadcrumbsContainer.style.display = 'flex';
            }

            // Get tool name or operation for breadcrumb label
            const toolName = row.querySelector('.tool-name');
            const label = toolName ? toolName.textContent : `Trace ${id.substring(0, 8)}`;

            // Add to breadcrumb stack if not already present
            if (!breadcrumbStack.includes(id)) {
                breadcrumbStack.push(id);

                const separator = document.createElement('span');
                separator.className = 'separator';
                separator.textContent = '>';

                const crumb = document.createElement('span');
                crumb.className = 'breadcrumb active';
                crumb.dataset.id = id;
                crumb.textContent = label;
                crumb.onclick = () => navigateToBreadcrumb(id);

                // Remove active class from previous breadcrumbs
                breadcrumbsContainer.querySelectorAll('.breadcrumb').forEach(b => {
                    b.classList.remove('active');
                });

                breadcrumbsContainer.appendChild(separator);
                breadcrumbsContainer.appendChild(crumb);
            }
        }

        function navigateToBreadcrumb(id) {
            // Find position in stack and remove everything after
            const index = breadcrumbStack.indexOf(id);
            if (index === -1) return;

            // Remove breadcrumbs after this one
            const breadcrumbsContainer = document.getElementById('trace-breadcrumbs');
            if (!breadcrumbsContainer) return;

            const allCrumbs = breadcrumbsContainer.querySelectorAll('.breadcrumb, .separator');

            let removing = false;
            allCrumbs.forEach(el => {
                if (removing) {
                    el.remove();
                }
                if (el.dataset && el.dataset.id === id) {
                    el.classList.add('active');
                    removing = true;
                }
            });

            // Update stack
            breadcrumbStack = breadcrumbStack.slice(0, index + 1);

            // Hide breadcrumbs if back to root
            if (breadcrumbStack.length <= 1) {
                breadcrumbsContainer.style.display = 'none';
            }
        }

        function resetBreadcrumbs() {
            const breadcrumbsContainer = document.getElementById('trace-breadcrumbs');
            if (!breadcrumbsContainer) return;

            breadcrumbsContainer.innerHTML = '<span class="breadcrumb" data-id="root" onclick="resetBreadcrumbs()">Session</span>';
            breadcrumbsContainer.style.display = 'none';
            breadcrumbStack = ['root'];

            // Collapse all traces
            collapseAllTraces();
        }

        // Initialize timestamps in activity feed after HTMX swap
        function initializeActivityFeedTimestamps() {
            document.querySelectorAll('.timestamp-text[data-utc-time]').forEach(el => {
                const utcTime = el.dataset.utcTime;
                if (utcTime) {
                    try {
                        const date = new Date(utcTime);
                        el.textContent = date.toLocaleTimeString();
                        el.title = date.toLocaleString();
                    } catch (e) {
                        // Keep original text if parsing fails
                    }
                }
            });
        }

        // Re-initialize after HTMX swaps in activity feed
        document.body.addEventListener('htmx:afterSwap', function(evt) {
            if (evt.detail.target && evt.detail.target.id === 'content-area') {
                initializeActivityFeedTimestamps();
            }
        });

        // ============================================
        // Spawner Activity Filtering
        // ============================================

        function filterByAgentType(filterType) {
            const turns = document.querySelectorAll('.conversation-turn');
            turns.forEach(turn => {
                const spawnerType = turn.dataset.spawnerType || 'direct';

                let shouldShow = false;
                if (filterType === 'all') {
                    shouldShow = true;
                } else if (filterType === 'direct') {
                    shouldShow = spawnerType === 'direct';
                } else if (filterType === 'spawner') {
                    shouldShow = spawnerType !== 'direct';
                } else {
                    // Specific spawner type (gemini, codex, copilot)
                    shouldShow = spawnerType === filterType;
                }

                if (shouldShow) {
                    turn.classList.remove('hidden');
                } else {
                    turn.classList.add('hidden');
                }
            });
        }
    </script>

    <!-- Styles for real-time event highlighting and spawner badges -->
    <style>
        .new-event-highlight {
            animation: highlightPulse 2s ease-out;
        }

        /* ============================================
           Spawner Badge Styling
           ============================================ */

        .delegation-arrow {
            color: var(--text-secondary);
            margin: 0 0.5rem;
            font-size: 0.9em;
            font-weight: normal;
        }

        .spawner-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.6rem;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
            border: 1px solid;
            background: white;
        }

        .spawner-badge.spawner-gemini {
            background: #e8f5e9;
            color: #2e7d32;
            border-color: #4caf50;
        }

        .spawner-badge.spawner-codex {
            background: #e3f2fd;
            color: #1565c0;
            border-color: #2196f3;
        }

        .spawner-badge.spawner-copilot {
            background: #f3e5f5;
            color: #6a1b9a;
            border-color: #9c27b0;
        }

        .cost-badge {
            font-size: 0.75rem;
            opacity: 0.8;
            margin-left: 0.25rem;
        }

        /* Activity feed spawner filter */
        .spawner-filter {
            padding: 0.75rem 1rem;
            margin: 0.5rem 0.5rem 1rem 0.5rem;
            border: 1px solid var(--border-subtle);
            border-radius: 4px;
            background: rgba(163, 230, 53, 0.02);
        }

        .spawner-filter label {
            margin-right: 0.5rem;
            font-weight: 500;
            font-size: 0.85rem;
        }

        .spawner-filter select {
            padding: 0.4rem 0.6rem;
            border: 1px solid var(--border-subtle);
            border-radius: 4px;
            background: var(--bg-base);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.85rem;
        }

        .spawner-filter select:hover {
            border-color: var(--accent, #c8ff00);
        }

        /* Hide turns based on filter */
        .conversation-turn.hidden {
            display: none;
        }

        @keyframes highlightPulse {
            0% {
                background-color: rgba(16, 185, 129, 0.2);
                border-left: 4px solid #10b981;
            }
            100% {
                background-color: transparent;
                border-left: 4px solid transparent;
            }
        }

        .auto-refresh-indicator {
            transition: opacity 0.3s ease;
        }

        .refresh-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
            background-color: #10b981;
            animation: pulse-dot 2s infinite;
        }

        @keyframes pulse-dot {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }
    </style>
</body>
</html>
