#!/bin/bash
#
# HtmlGraph Code Verification Script for AI Spawners
#
# Lightweight verification for code generated by Gemini/Codex.
# Designed to be fast and provide clear pass/fail feedback.
#
# Usage:
#   ./scripts/verify-code.sh file.py       # Verify single file
#   ./scripts/verify-code.sh src/module/   # Verify directory
#   ./scripts/verify-code.sh --auto-fix    # Auto-fix issues
#
# Exit Codes:
#   0 = Code is valid
#   1 = Code has issues
#
# For AI Spawners:
#   Include this in your spawner output validation:
#
#   result = spawn_codex("Implement feature X")
#   if result.success:
#       # Verify the generated code
#       exit_code = run("./scripts/verify-code.sh src/path/to/file.py")
#       if exit_code != 0:
#           # Iterate with same spawner, don't escalate to Claude
#           spawn_codex("Fix the issues in src/path/to/file.py")
#

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Parse arguments
TARGET=""
AUTO_FIX=false
VERBOSE=false

for arg in "$@"; do
    case $arg in
        --auto-fix|--fix)
            AUTO_FIX=true
            ;;
        --verbose|-v)
            VERBOSE=true
            ;;
        --help|-h)
            echo "Usage: $0 <file_or_directory> [--auto-fix] [--verbose]"
            echo ""
            echo "Options:"
            echo "  --auto-fix   Automatically fix linting issues"
            echo "  --verbose    Show detailed output"
            exit 0
            ;;
        *)
            TARGET=$arg
            ;;
    esac
done

# Require target
if [ -z "$TARGET" ]; then
    echo -e "${RED}Error: No file or directory specified${NC}"
    echo "Usage: $0 <file_or_directory>"
    exit 1
fi

# Check target exists
if [ ! -e "$TARGET" ]; then
    echo -e "${RED}Error: $TARGET does not exist${NC}"
    exit 1
fi

echo -e "${BLUE}Verifying: $TARGET${NC}"
echo ""

ISSUES=0

# Step 1: Syntax check (fast)
echo -n "Syntax... "
if python3 -m py_compile "$TARGET" 2>/dev/null || [ -d "$TARGET" ]; then
    echo -e "${GREEN}OK${NC}"
else
    echo -e "${RED}INVALID${NC}"
    ISSUES=$((ISSUES + 1))
fi

# Step 2: Ruff check
echo -n "Lint... "
if [ "$AUTO_FIX" = true ]; then
    if uv run ruff check --fix "$TARGET" 2>/dev/null; then
        echo -e "${GREEN}FIXED${NC}"
    else
        echo -e "${YELLOW}FIXED (with warnings)${NC}"
    fi
else
    if uv run ruff check "$TARGET" 2>/dev/null; then
        echo -e "${GREEN}OK${NC}"
    else
        echo -e "${RED}ISSUES${NC}"
        ISSUES=$((ISSUES + 1))
        if [ "$VERBOSE" = true ]; then
            uv run ruff check "$TARGET" 2>&1 || true
        fi
    fi
fi

# Step 3: Format check
echo -n "Format... "
if [ "$AUTO_FIX" = true ]; then
    uv run ruff format "$TARGET" 2>/dev/null
    echo -e "${GREEN}FORMATTED${NC}"
else
    if uv run ruff format --check "$TARGET" 2>/dev/null; then
        echo -e "${GREEN}OK${NC}"
    else
        echo -e "${YELLOW}NEEDS FORMAT${NC}"
        ISSUES=$((ISSUES + 1))
    fi
fi

# Step 4: Type check (for files in src/)
if echo "$TARGET" | grep -q "src/python"; then
    echo -n "Types... "
    if uv run mypy "$TARGET" --ignore-missing-imports 2>/dev/null; then
        echo -e "${GREEN}OK${NC}"
    else
        echo -e "${RED}ISSUES${NC}"
        ISSUES=$((ISSUES + 1))
        if [ "$VERBOSE" = true ]; then
            uv run mypy "$TARGET" --ignore-missing-imports 2>&1 || true
        fi
    fi
fi

# Summary
echo ""
if [ $ISSUES -eq 0 ]; then
    echo -e "${GREEN}Code verification passed.${NC}"
    exit 0
else
    echo -e "${RED}Found $ISSUES issue(s).${NC}"
    echo ""
    echo "To fix automatically:"
    echo "  $0 $TARGET --auto-fix"
    echo ""
    echo "Or manually:"
    echo "  uv run ruff check --fix $TARGET"
    echo "  uv run ruff format $TARGET"
    exit 1
fi
