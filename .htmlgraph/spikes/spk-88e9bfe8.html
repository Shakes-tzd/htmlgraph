<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="htmlgraph-version" content="1.0">
    <title>SubagentStart/Stop Hook Research Findings</title>
    <link rel="stylesheet" href="../styles.css">
</head>
<body>
    <article id="spk-88e9bfe8"
             data-type="spike"
             data-status="todo"
             data-priority="medium"
             data-created="2025-12-31T22:03:35.801372"
             data-updated="2025-12-31T22:03:35.801378" data-spike-type="general" data-timebox-hours="4">

        <header>
            <h1>SubagentStart/Stop Hook Research Findings</h1>
            <div class="metadata">
                <span class="badge status-todo">Todo</span>
                <span class="badge priority-medium">Medium Priority</span>
            </div>
        </header>

    
        <section data-spike-metadata>
            <h3>Spike Metadata</h3>
            <dl>
                <dt>Type</dt>
                <dd>General</dd>
                <dt>Timebox</dt>
                <dd>4 hours</dd>
            </dl>
        </section>
        <section data-findings>
            <h3>Findings</h3>
            <div class="findings-content">
                
## Research Summary

Comprehensive research into Claude Code's SubagentStart and SubagentStop hooks for reliable task tracking and result collection.

---

## SubagentStart Hook

### Status: **NOT YET IMPLEMENTED** âŒ

The SubagentStart hook was **requested in GitHub issue #14859** (Dec 20, 2025) but **remains OPEN** with no implementation.

### Proposed Functionality

**Purpose**: Fire when a sub-agent is spawned via the Task tool

**Proposed Schema**:
```json
{
  "hook_event_type": "SubagentStart",
  "agent_id": "new-agent-id",
  "parent_agent_id": "parent-id",
  "subagent_type": "Explore",
  "description": "Search for auth patterns"
}
```

### Why It's Needed

- **Current Issue**: All hook events share the same session_id, making agent attribution impossible
- **Impact**: Cannot build observability dashboards or track parallel multi-agent execution
- **Priority**: CRITICAL - Blocking real-time observability tooling

### Workaround for Now

**Use PreToolUse hook with Task tool matcher:**

```json
{
  "hooks": {
    "PreToolUse": [{
      "matcher": "Task",
      "hooks": [{
        "type": "command",
        "command": "uv run .claude/hooks/task_start.py"
      }]
    }]
  }
}
```

This fires BEFORE Task tool execution and receives:
- `tool_name`: "Task"
- `tool_input`: { "subagent_type": "...", "prompt": "...", "description": "..." }
- `session_id`: Current session ID

---

## SubagentStop Hook

### Status: **IMPLEMENTED** âœ… (v1.0.41+)

The SubagentStop hook is available but has **significant limitations**.

### Hook Signature

**Input (JSON via stdin):**
```json
{
  "hook_event_name": "SubagentStop",
  "session_id": "cb67a406-fd98-47ca-9b03-fcca9cc43e8d",
  "transcript_path": "/path/to/agent-abc123.jsonl",
  "stop_hook_active": false
}
```

**Output (JSON to stdout):**
```json
{
  "action": "approve",
  "reason": "Subagent completed successfully"
}
```

Or for blocking:
```json
{
  "action": "block",
  "reason": "Results incomplete, continue working",
  "stopReason": "task_not_finished",
  "systemMessage": "Please complete all steps before stopping"
}
```

### Configuration Examples

**Basic Logging:**
```json
{
  "hooks": {
    "SubagentStop": [{
      "hooks": [{
        "type": "command",
        "command": "echo 'Subagent completed at Wed Dec 31 22:03:35 EST 2025' >> ~/.claude/subagent-log.txt"
      }]
    }]
  }
}
```

**Python Hook:**
```json
{
  "hooks": {
    "SubagentStop": [{
      "hooks": [{
        "type": "command",
        "command": "uv run .claude/hooks/subagent_stop.py"
      }]
    }]
  }
}
```

**Prompt-Based Hook (LLM evaluation):**
```json
{
  "hooks": {
    "SubagentStop": [{
      "hooks": [{
        "type": "prompt",
        "prompt": "Evaluate if the subagent completed all tasks. Return approve or block with reasoning."
      }]
    }]
  }
}
```

### Python Implementation Example

```python
#!/usr/bin/env python3
# /// script
# requires-python = ">=3.11"
# dependencies = []
# ///

import sys
import json
from datetime import datetime
from pathlib import Path

def main():
    # Read hook input from stdin
    hook_input = json.load(sys.stdin)
    
    session_id = hook_input.get("session_id")
    transcript_path = hook_input.get("transcript_path")
    
    # Read subagent transcript for results
    if transcript_path and Path(transcript_path).exists():
        with open(transcript_path) as f:
            lines = f.readlines()
            # Parse JSONL format
            events = [json.loads(line) for line in lines]
            
            # Extract final assistant message
            final_message = None
            for event in reversed(events):
                if event.get("type") == "text" and event.get("role") == "assistant":
                    final_message = event.get("content", {}).get("text")
                    break
    
    # Log completion
    log_entry = {
        "event": "SubagentStop",
        "session_id": session_id,
        "timestamp": datetime.now().isoformat(),
        "transcript": transcript_path
    }
    
    # Print to stdout (visible in transcript)
    print(f"âœ… Subagent completed at {datetime.now().strftime('%H:%M:%S')}")
    
    # Return approval
    result = {
        "action": "approve",
        "reason": "Subagent task completed"
    }
    print(json.dumps(result))

if __name__ == "__main__":
    main()
```

### CRITICAL LIMITATION: Shared Session ID Problem

**GitHub Issue #7881**: SubagentStop cannot identify which specific subagent finished.

**The Problem:**
All subagents in the same session share the same session_id:

```json
// PreToolUse for subagent A
{ "session_id": "abc123", "tool_input": { "subagent_type": "frontend" } }

// PreToolUse for subagent B (SAME SESSION ID!)
{ "session_id": "abc123", "tool_input": { "subagent_type": "backend" } }

// SubagentStop (which one stopped?)
{ "session_id": "abc123", "transcript_path": "..." }
```

**Impact:**
- âŒ Cannot track individual subagent performance
- âŒ Cannot maintain agent-specific state
- âŒ Parallel execution breaks tracking (session map gets overwritten)
- âŒ No reliable correlation between Task spawn and completion

**Proposed Solutions (not yet implemented):**

1. **Add subagent_id + subagent_type:**
```json
{
  "session_id": "abc123",
  "subagent_id": "abc123-task-001",
  "subagent_type": "frontend"
}
```

2. **Unique subagent_session (recommended):**
```json
{
  "session_id": "abc123",
  "subagent_session": "abc123-task-001",
  "subagent_type": "frontend"
}
```

---

## Current Best Practices

### 1. Use PreToolUse Hook for Task Tracking

Track Task tool invocations to capture subagent spawn:

```python
# .claude/hooks/pre_tool_use.py
import sys
import json

hook_input = json.load(sys.stdin)

if hook_input.get("tool_name") == "Task":
    tool_input = hook_input.get("tool_input", {})
    task_id = f"{hook_input['session_id']}-{int(time.time() * 1000)}"
    
    # Store task mapping
    store_task({
        "task_id": task_id,
        "subagent_type": tool_input.get("subagent_type"),
        "description": tool_input.get("description"),
        "prompt": tool_input.get("prompt"),
        "started_at": datetime.now().isoformat()
    })
```

### 2. Parse Transcript in SubagentStop

Use transcript_path to read results:

```python
# .claude/hooks/subagent_stop.py
import json
from pathlib import Path

hook_input = json.load(sys.stdin)
transcript_path = hook_input.get("transcript_path")

if transcript_path and Path(transcript_path).exists():
    with open(transcript_path) as f:
        events = [json.loads(line) for line in f]
        
        # Extract final output
        final_text = extract_final_assistant_message(events)
        
        # Save to HtmlGraph spike
        save_subagent_results(final_text)
```

### 3. Workaround for Parallel Execution

**Option A: Timestamp-based correlation (unreliable)**
```python
# Match most recent Task spawn to SubagentStop
# PROBLEM: Breaks with parallel tasks
```

**Option B: Parse description from prompt injection**
```python
# Inject unique ID in Task prompt
Task(
    prompt=f"""
    TASK_ID: {unique_id}
    
    {actual_task_prompt}
    """,
    description=f"{unique_id}: {description}"
)

# Extract ID from transcript in SubagentStop
```

**Option C: File-based state (current HtmlGraph approach)**
```python
# PreToolUse writes state file
# SubagentStop reads state file
# PROBLEM: Race conditions with parallel tasks
```

---

## Integration with HtmlGraph

### Recommended Approach (Until SubagentStart is implemented)

**1. Hook Configuration:**

```json
{
  "hooks": {
    "PreToolUse": [{
      "matcher": "Task",
      "hooks": [{
        "type": "command",
        "command": "uv run .claude/hooks/task_spawn.py"
      }]
    }],
    "SubagentStop": [{
      "hooks": [{
        "type": "command",
        "command": "uv run .claude/hooks/subagent_results.py"
      }]
    }]
  }
}
```

**2. Task Spawn Hook (.claude/hooks/task_spawn.py):**

```python
#!/usr/bin/env python3
# /// script
# requires-python = ">=3.11"
# dependencies = ["htmlgraph"]
# ///

import sys
import json
from htmlgraph import SDK

hook_input = json.load(sys.stdin)

if hook_input.get("tool_name") == "Task":
    tool_input = hook_input.get("tool_input", {})
    
    sdk = SDK(agent="hook-tracker")
    
    # Create spike for tracking
    spike = sdk.spikes.create(f"Task Delegation: {tool_input.get('description', 'Unknown')}")
    spike.set_hypothesis(f"""
Subagent Type: {tool_input.get('subagent_type')}
Description: {tool_input.get('description')}
Prompt: {tool_input.get('prompt')[:200]}...
Session ID: {hook_input['session_id']}
Started: {datetime.now().isoformat()}
    """).save()
    
    # Store spike ID for correlation
    # PROBLEM: How to retrieve in SubagentStop?
```

**3. Subagent Results Hook (.claude/hooks/subagent_results.py):**

```python
#!/usr/bin/env python3
# /// script
# requires-python = ">=3.11"
# dependencies = ["htmlgraph"]
# ///

import sys
import json
from pathlib import Path
from htmlgraph import SDK

hook_input = json.load(sys.stdin)
transcript_path = hook_input.get("transcript_path")

if transcript_path and Path(transcript_path).exists():
    with open(transcript_path) as f:
        events = [json.loads(line) for line in f]
        
        # Extract final message
        final_text = None
        for event in reversed(events):
            if event.get("type") == "text" and event.get("role") == "assistant":
                final_text = event.get("content", {}).get("text")
                break
        
        if final_text:
            sdk = SDK(agent="hook-tracker")
            
            # PROBLEM: Which spike to update?
            # Need correlation mechanism
            
            # For now: Create new spike
            spike = sdk.spikes.create("Subagent Completed")
            spike.set_findings(final_text).save()
```

### The Fundamental Problem

**Without SubagentStart or unique subagent identifiers, reliable correlation is impossible.**

Current workarounds all have race conditions or fail with parallel execution.

---

## Recommendations for HtmlGraph

### Short-Term: Live with TaskOutput Unreliability

1. **Document the limitation** - TaskOutput is unreliable, use manual spike creation
2. **Use manual patterns** - Subagents explicitly call SDK to report results
3. **Wait for SubagentStart** - Track GitHub issue #14859

### Medium-Term: Workaround with Prompt Injection

1. **Generate unique task IDs** in orchestrator
2. **Inject ID in task prompt** and description
3. **Parse transcript** in SubagentStop to extract ID
4. **Correlate** to spike created in PreToolUse

```python
# Orchestrator
task_id = f"task-{uuid.uuid4().hex[:8]}"
Task(
    prompt=f"""
    ðŸ”´ TASK_ID: {task_id}
    
    {actual_prompt}
    
    When reporting results, include: TASK_ID: {task_id}
    """,
    description=f"{task_id}: {description}"
)

# SubagentStop hook parses transcript for TASK_ID marker
```

### Long-Term: Wait for Official Solution

Monitor these GitHub issues:
- **#14859** - SubagentStart hook + agent hierarchy
- **#7881** - Unique subagent identifiers
- **#5812** - Context bridging between agents

---

## References

### Official Documentation
- [Claude Code Hooks Reference](https://code.claude.com/docs/en/hooks)
- [Hooks Guide](https://docs.claude.com/en/docs/claude-code/hooks-guide)
- [Subagents Documentation](https://code.claude.com/docs/en/sub-agents)

### GitHub Issues
- [#14859 - SubagentStart Hook Feature Request](https://github.com/anthropics/claude-code/issues/14859)
- [#7881 - SubagentStop Shared Session ID Problem](https://github.com/anthropics/claude-code/issues/7881)
- [#5812 - Context Bridging Between Agents](https://github.com/anthropics/claude-code/issues/5812)

### Community Examples
- [disler/claude-code-hooks-mastery](https://github.com/disler/claude-code-hooks-mastery)
- [disler/claude-code-hooks-multi-agent-observability](https://github.com/disler/claude-code-hooks-multi-agent-observability)

### Blog Posts
- [Best Practices for Claude Code Subagents](https://www.pubnub.com/blog/best-practices-for-claude-code-sub-agents/)
- [Claude Code Power User Customization](https://claude.com/blog/how-to-configure-hooks)

            </div>
        </section>
    </article>
</body>
</html>
