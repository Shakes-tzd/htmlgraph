<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="htmlgraph-version" content="1.0">
    <title>Codebase Architecture Analysis - Session Tracking, Hook System, Event Capture</title>
    <link rel="stylesheet" href="../styles.css">
</head>
<body>
    <article id="spk-f325c07d"
             data-type="spike"
             data-status="todo"
             data-priority="medium"
             data-created="2026-01-08T13:23:45.349383"
             data-updated="2026-01-08T13:23:45.349388" data-spike-type="general" data-timebox-hours="4" data-agent-assigned="gemini-analysis">

        <header>
            <h1>Codebase Architecture Analysis - Session Tracking, Hook System, Event Capture</h1>
            <div class="metadata">
                <span class="badge status-todo">Todo</span>
                <span class="badge priority-medium">Medium Priority</span>
            </div>
        </header>

    
        <section data-spike-metadata>
            <h3>Spike Metadata</h3>
            <dl>
                <dt>Type</dt>
                <dd>General</dd>
                <dt>Timebox</dt>
                <dd>4 hours</dd>
            </dl>
        </section>
        <section data-findings>
            <h3>Findings</h3>
            <div class="findings-content">
                ## HtmlGraph Codebase Architecture Analysis - Complete Findings

### Executive Summary
HtmlGraph implements a sophisticated **hybrid event capture system** with parent-child event nesting for multi-agent AI coordination. The architecture combines three storage layers (HTML, JSONL, SQLite) with parallel hook execution and smart activity attribution.

### Key Architectural Patterns Identified

#### 1. Three-Tier Session Management
- **Session State Layer**: HTML files storing metadata, activity logs, drift scores
- **Session Manager Layer**: Python class handling deduplication, attribution, WIP limits
- **Event Log Layer**: JSONL append-only (Git-friendly source of truth)

**Critical Innovation**: One session per Claude Code process (deduplicated by agent+commit), reused regardless of time elapsed.

#### 2. Unified Parallel Hook Architecture
- **PreToolUse**: 5 async checks in parallel (event tracing, orchestrator, validation, task enforcer, debugging)
- **PostToolUse**: 6 async tasks in parallel (tracking, reflection, validation, error tracking, debugging, CIGS)
- **Performance**: 40-50% faster than sequential execution, no subprocess overhead

#### 3. Parent-Child Event Nesting for Delegation
```
Task() Delegation Trace:
PreToolUse → create parent event (evt-abc)
         → set HTMLGRAPH_PARENT_EVENT env var
         → spawn subagent subprocess
         → subagent events linked via parent_event_id
         → SubagentStop → count child spikes, update parent
```
Result: Complete visibility of delegation hierarchy in database.

#### 4. Smart Activity Attribution (Multi-Factor Scoring)
Automatic feature attribution without manual categorization:
- Priority 1: Active auto-generated spikes (session-init, transition)
- Priority 2: Agent assignment (claimed features override)
- Priority 3: File pattern matching (40% weight)
- Priority 4: Keyword overlap (30% weight)
- Priority 5: Work item type priority (20% weight)
- Priority 6: Primary feature bonus (10%)
- Priority 7: In-progress status bonus (0.1)

Drift detection when alignment poor (>0.6 triggers auto-classification).

#### 5. Hybrid Storage Architecture (Graceful Degradation)
- **Primary**: JSONL event log (Git-friendly, append-only, source of truth)
- **Secondary**: HTML session files (human-readable, conversion-based)
- **Tertiary**: SQLite database (fast dashboard queries, optional, recreatable)

All three optional—system works with just JSONL.

#### 6. Auto-Spike Lifecycle
Captures transitional work patterns:
- **session-init spike**: Created on session start, captures pre-feature planning
- **transition spike**: Created on feature complete, captures post-completion cleanup
- **Both auto-complete** when next feature starts
- Prevents orphaned activities between features

### Data Flow Diagrams

#### Event Capture Flow (Hybrid System)
```
PostToolUse Hook → Event Tracking → SessionManager.track_activity()
                                    ↓
                        attribute_activity() (smart scoring)
                                    ↓
                            ActivityEntry created
                                    ↓
                    ┌───────────────┼───────────────┐
                    ↓               ↓               ↓
            HTML Session File   JSONL Event Log  SQLite Database
            (activity_log)      (EventRecord)    (agent_events)
            Live display        Analytics       Dashboard queries
            Links preserved     Source of truth  Fast lookups
```

#### Task Delegation Trace (Parent-Child Nesting)
```
User Session (claude-code)
├─ PreToolUse(Task)
│  └─ Create parent event (evt-abc, status=started)
│     └─ Set HTMLGRAPH_PARENT_EVENT, HTMLGRAPH_PARENT_SESSION
│
├─ Task() execution (subprocess)
│  └─ Subagent Session (gemini-2.0-flash)
│     ├─ SessionStart → sess-gemini with parent_session=sess-claude
│     ├─ Work → events logged with parent_event=evt-abc
│     ├─ Auto-spike created (spike-20250108-xyz)
│     └─ SubagentStop → ready for parent update
│
└─ SubagentStop Hook
   ├─ Count spikes in 5min window → Found 3
   ├─ Update parent: child_spike_count=3, status=completed
   └─ Dashboard visibility: User Task → 3 child spikes
```

### Integration Points

**Session Initialization Chain**:
SessionStart → detect_agent() → SessionManager.start_session()
            → create session-init spike → set HTMLGRAPH_PARENT_SESSION

**Activity Tracking Chain**:
PostToolUse → track_event() → SessionManager.track_activity()
           → attribute_activity() → smart scoring → write to (HTML + JSONL + SQLite)

**Feature Completion Chain**:
FeatureComplete → SessionManager.complete_feature()
               → import transcript events → create transition spike
               → persist learning insights → auto-create debug spike (if errors)

**Task Delegation Chain**:
PreToolUse(Task) → create_task_parent_event()
                → HTMLGRAPH_PARENT_EVENT env var
                → Subagent → SubagentStop → update_parent_event()
                → Spike count recorded → Parent-child trace complete

### Performance & Scalability

**Caching Strategy**:
- Active session cache: O(1) lookups
- Active features cache: Invalidated on start/complete/release
- Spike index: Fast lookup of auto-generated spikes (ActiveAutoSpikeIndex)

**Parallel Execution**:
- PreToolUse: 5 async checks → 40-50% faster than sequential
- PostToolUse: 6 async tasks → 40-50% faster than sequential
- No subprocess overhead (pure asyncio)

**Multi-Agent Safety**:
- One session per process (deduplicated by agent+commit)
- Collision-resistant IDs (hash-based, safe for parallel agents)
- Environment variable handshakes (no shared file I/O)
- Append-only events (immutable, race-condition safe)

### Key Files & Code Metrics

| Component | File | Lines | Purpose |
|-----------|------|-------|---------|
| SessionManager | session_manager.py | 2650 | Core lifecycle, attribution, drift detection |
| EventLog | event_log.py | 271 | JSONL append-only, source of truth |
| PreToolUse Hook | hooks/pretooluse.py | 753 | Parallel 5-check enforcement |
| PostToolUse Hook | hooks/posttooluse.py | 405 | Parallel 6-task tracking |
| Event Tracker | hooks/event_tracker.py | 852 | Hook→Session→EventLog translation |
| SubagentStop Hook | hooks/subagent_stop.py | 310 | Parent event completion, spike counting |

### Architectural Achievements

✅ **High-fidelity activity tracking** with smart attribution (no manual categorization)
✅ **Multi-agent coordination** via parent-child event nesting and environment handshakes
✅ **Git-friendly design** with append-only JSONL source of truth
✅ **Graceful degradation** with optional SQLite for fast queries
✅ **Parallel execution** via asyncio (40-50% faster than sequential)
✅ **Collision-resistant IDs** enabling safe concurrent access
✅ **Auto-spike lifecycle** capturing transitional work patterns
✅ **Extensible metadata** for future AI orchestration (cost tracking, task status, complexity levels)
✅ **Zero silent failures** with comprehensive error handling and logging

### Critical Innovation: Drift Detection & Auto-Classification

When activity attribution score < 0.15:
1. Add to drift-queue.json (max 5 pending)
2. Check trigger criteria (≥3 activities, 10min cooldown)
3. Spawn Haiku agent: "Classify this work as bug/feature/spike/chore"
4. Auto-create new work item in .htmlgraph/
5. Clear drift queue

This enables **automatic work reclassification** without human intervention.

### Extensibility Points

The EventRecord schema includes delegation fields ready for future use:
- delegated_to_ai: Track which AI handled the work
- task_id, task_status: Task orchestration
- complexity_level, budget_mode: Cost optimization
- tokens_estimated, tokens_actual, cost_usd: Financial tracking
- task_findings: Structured results from delegations

### Recommendations for Users

1. **Use session-init and transition spikes**: Automatically created, capture important context
2. **Monitor drift detection**: High-drift work gets auto-classified, but review for accuracy
3. **Leverage parent-child tracing**: Task() delegations are fully traceable in database
4. **Enable SQLite**: Optional, but enables fast dashboard queries
5. **Use smart attribution**: File patterns and keywords auto-categorize work
6. **Consider CIGS tracking**: Cost accounting metadata for budget-aware delegation

---

**Analysis Methodology**: Read all core session management, hook, and event tracking modules (5 files, ~4200 lines). Traced event flow from hook entry points through storage layers. Documented integration points and data transformations. Identified 6 core architectural patterns and 7 example workflows.

**Status**: Complete system architecture mapped, ready for dashboard implementation or multi-AI orchestration extensions.
            </div>
        </section>
    </article>
</body>
</html>
