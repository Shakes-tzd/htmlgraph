<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="htmlgraph-version" content="1.0">
    <title>HtmlGraph Codebase Architecture Analysis</title>
    <link rel="stylesheet" href="../styles.css">
</head>
<body>
    <article id="spk-69a0439f"
             data-type="spike"
             data-status="todo"
             data-priority="medium"
             data-created="2026-01-08T11:56:45.858324"
             data-updated="2026-01-08T11:56:45.858328" data-spike-type="architectural" data-timebox-hours="4" data-agent-assigned="gemini-explorer">

        <header>
            <h1>HtmlGraph Codebase Architecture Analysis</h1>
            <div class="metadata">
                <span class="badge status-todo">Todo</span>
                <span class="badge priority-medium">Medium Priority</span>
            </div>
        </header>

    
        <section data-spike-metadata>
            <h3>Spike Metadata</h3>
            <dl>
                <dt>Type</dt>
                <dd>Architectural</dd>
                <dt>Timebox</dt>
                <dd>4 hours</dd>
            </dl>
        </section>
        <section data-findings>
            <h3>Findings</h3>
            <div class="findings-content">
                ## HtmlGraph Codebase Architecture Analysis

### 1. PACKAGE STRUCTURE

**Core Organization:**
- `src/python/htmlgraph/` - Main package (140+ Python modules)
- Modular design with clear domain separation
- Auto-discovery of `.htmlgraph` directory for project integration

**Major Module Groups:**

**Database Layer** (`db/`)
- `schema.py` - SQLite schema with 9 tables, 30+ indexes
- Normalization with JSON columns for flexibility
- Foreign key constraints for referential integrity

**Graph Engine** (`graph.py`, `parser.py`, `converter.py`)
- File-based graph with HTML serialization
- CSS selector queries (`:not()`, `[attr~=value]`)
- Edge indexing for O(1) lookups
- Transaction/snapshot support for concurrency

**Collections** (`collections/`)
- Feature, Bug, Chore, Spike, Epic, Phase, Session, Task, Todo
- Shared BaseCollection with query builder patterns
- Fluent API with method chaining
- Pydantic models for validation

**Hook System** (`hooks/`)
- PreToolUse: Parallel orchestrator + validator + event tracing
- PostToolUse: Parallel event tracking + reflection + validation
- SessionStart: Environment variable injection + session init
- Custom validators, orchestrators, error handlers

**API & Dashboard** (`api/`)
- FastAPI backend with SQLite queries
- HTMX for interactive UI without page reloads
- WebSocket real-time event streaming
- Query cache with TTL (30s default)
- Jinja2 template rendering

**Session Management** (`session_manager.py`, `session_state.py`, `session_registry.py`)
- Smart attribution scoring (file patterns, keywords, type priority)
- Drift detection (time-based, event-based)
- WIP limit enforcement (default: 3 items)
- Auto-completion and status tracking

**Orchestration** (`orchestration/`)
- HeadlessSpawner for model delegation
- Task coordination and cost tracking
- Model selection strategies

**Analytics** (`analytics/`)
- Cross-session analysis
- Dependency tracking
- Work type classification

---

### 2. DATABASE DESIGN

**Schema (SQLite):**

```
Core Tables:
├── agent_events (100K+ rows expected)
│   ├── PK: event_id
│   ├── Session tracking: session_id, parent_event_id
│   ├── Tool execution: tool_name, input_summary, output_summary
│   ├── Audit: created_at, updated_at, status
│   └── Performance: cost_tokens, execution_duration_seconds
│
├── features (1K-10K rows)
│   ├── PK: id
│   ├── Types: feature, bug, spike, chore, epic, task
│   ├── Status: todo, in_progress, blocked, done, cancelled
│   ├── Tracking: parent_feature_id, track_id, assigned_to
│   └── Progress: steps_total, steps_completed
│
├── sessions (100-1K rows)
│   ├── PK: session_id
│   ├── Hierarchy: parent_session_id, parent_event_id (subagent support)
│   ├── Metrics: total_events, total_tokens_used, context_drift
│   └── Status: active, completed, paused, failed
│
├── tracks (10-100 rows)
│   ├── Multi-feature initiatives
│   ├── Status: todo, in_progress, blocked, done, cancelled
│   └── JSON: features list, metadata
│
├── agent_collaboration (1K+ rows)
│   ├── Handoff tracking: handoff_type, from_agent, to_agent
│   ├── Types: delegation, parallel, sequential, fallback
│   ├── Status: pending, accepted, rejected, completed, failed
│   └── Context: reason, result
│
├── graph_edges (flexible relationship tracking)
│   ├── General: from_node_id, to_node_id, relationship_type
│   ├── Flexible: from_node_type, to_node_type
│   └── Weighted: weight REAL
│
├── tool_traces (high-volume audit log)
│   ├── PK: tool_use_id
│   ├── Correlation: trace_id, parent_tool_use_id
│   ├── Execution: tool_input, tool_output, duration_ms
│   └── Status: started, completed, failed, timeout, cancelled
│
└── event_log_archive (historical summaries)
    ├── Daily summaries: event_date, event_count
    └── Aggregate: total_tokens, summary
```

**Indexing Strategy (30 indexes):**
- Session queries: `idx_agent_events_session`, `idx_sessions_created`
- Status filtering: `idx_features_status`, `idx_tracks_status`
- Tool traces: 5 indexes for correlation (trace_id), tool_name, status
- Type-based: `idx_features_type`, `idx_agent_events_type`
- Performance: All date-based as DESC for recent-first queries

**Design Decisions:**
- JSON columns for flexible metadata (tags, features list)
- Foreign keys with CASCADE support
- Composite indexes for multi-field queries
- Timestamp fields (ISO8601 UTC) for cross-timezone compatibility

---

### 3. HOOK SYSTEM ARCHITECTURE

**PreToolUse Hook** (`pretooluse.py`):
```
Parallel Execution:
├── Orchestrator Check (enforce delegation boundaries)
├── Work Validator (validate against whitelist/blacklist)
├── Event Tracing (generate tool_use_id, insert start event)
└── Task Enforcement (auto-save TodoWrite)

Result: Blocking response only if both checks agree
Performance: 40-50% faster than sequential via asyncio.gather()
Correlation: tool_use_id links PreToolUse → PostToolUse
```

**PostToolUse Hook** (`posttooluse.py`):
```
Parallel Tasks (asyncio.gather()):
├── Event Tracking (session attribution, drift detection)
├── Orchestrator Reflection (delegation suggestions)
├── Task Validation (TodoWrite compliance)
├── Error Tracking (auto-spike creation after 3+ errors)
├── Debugging Suggestions (resource recommendations)
└── CIGS Analysis (cost accounting, reinforcement)

Error Handling: Graceful degradation - all failures allow execution
```

**SessionStart Hook** (`session_hooks.py`):
```
Initialization:
├── Detect session source (startup, resume, compact, clear)
├── Create session record (sessions table)
├── Set environment variables:
│   ├── HTMLGRAPH_SESSION_ID
│   ├── CLAUDE_SESSION_SOURCE
│   ├── CLAUDE_DELEGATION_ENABLED
│   └── CLAUDE_PROMPT_PERSISTENCE_VERSION
└── Inject system prompt (3-layer persistence)
```

**Session State Detection:**
- Session ID extraction from filename or registry
- Post-compact detection via marker files
- Delegation status from orchestrator mode
- Validation through environment variable checks

---

### 4. API LAYER ARCHITECTURE

**FastAPI Backend** (`api/main.py`):

**Endpoints:**
```
GET /api/events
  ├── Query: session_id, agent_id, timestamp range
  ├── Cache: 30s TTL via QueryCache
  └── Response: EventModel[] (sorted by timestamp DESC)

GET /api/features
  ├── Query: status, type, track_id, priority
  ├── Filter: WHERE clauses built dynamically
  └── Response: FeatureModel[]

GET /api/sessions
  ├── Query: agent_id, status, date range
  ├── Metrics: total_events, total_tokens_used
  └── Response: SessionModel[]

GET /api/tool-traces
  ├── Query: session_id, tool_name, trace_id
  ├── Ordering: start_time DESC (recent first)
  └── Response: ToolTraceModel[]

WebSocket /ws/events
  ├── Real-time streaming of new agent_events
  ├── Filters: session_id, agent_id
  └── Format: JSON with timestamp/status
```

**Query Cache Performance:**
- Simple TTL-based in-memory cache
- Metrics tracking: hit rate, avg query time
- Keys: `f"events:{session_id}"`, `f"features:{status}"`
- Eviction: Auto-clean on TTL expiry

**Database Access:**
- aiosqlite for async queries
- Row factory: `sqlite3.Row` for dict-like access
- Foreign key constraints enabled (PRAGMA foreign_keys = ON)
- Connection pooling via persistent connection

**Frontend Integration:**
- HTMX for interactive Kanban views
- Jinja2 server-side rendering
- Static files served via StaticFiles mount
- WebSocket auto-reconnect on disconnect

---

### 5. FRONTEND DASHBOARD

**Technology Stack:**
- HTML5 + CSS3 + vanilla JavaScript (zero-dependency)
- HTMX for interactive updates without page reload
- Jinja2 templates (server-side rendering)
- WebSocket for real-time event streaming

**Dashboard Views:**

**Activity Feed:**
```
Real-time event streaming via WebSocket
├── Tool calls (Bash, Read, Edit, Write, etc.)
├── Tool results (success/failure with summaries)
├── Errors with auto-spike links
└── Delegations (from_agent → to_agent)

Display: Chronological feed with collapsible details
Filtering: By session, agent, event type
```

**Feature Tracker (Kanban):**
```
Board Layout:
├── TODO column (status='todo')
├── IN PROGRESS column (status='in_progress')
├── BLOCKED column (status='blocked')
└── DONE column (status='done')

Card Design:
├── Title (feature.title)
├── Type badge (feature, bug, spike, etc.)
├── Priority color (low/medium/high/critical)
├── Progress bar (steps_completed / steps_total)
├── Assigned agent
└── Tags (JSON array rendered)

Interactions: Drag-drop via HTMX, click to expand
```

**Session Metrics:**
```
Summary View:
├── Session ID + Agent name
├── Status (active/completed/paused/failed)
├── Duration (created_at → completed_at)
├── Event count (total_events)
├── Token usage (total_tokens_used)
├── Context drift score (0.0-1.0)
└── Features worked on (JSON array)

Timeline: Start → Activity → End with gaps highlighted
```

**Tool Trace Timeline:**
```
Trace Visualization:
├── Tool name (Bash, Read, Edit, etc.)
├── Duration (end_time - start_time in ms)
├── Status (completed/failed/timeout/cancelled)
├── Input/output preview (truncated)
├── Error message (if failed)
└── Nesting (parent_tool_use_id → child traces)

Correlation: Links PreToolUse ↔ PostToolUse via tool_use_id
```

**Auto-Updates:**
- WebSocket pushes new events to connected clients
- HTMX POST requests for view updates
- Cache invalidation on mutations
- Optimistic UI (show action immediately)

---

### 6. KEY ARCHITECTURAL PATTERNS

**1. Dual Storage Strategy:**
```
HTML Files (graph/)              SQLite Database (htmlgraph.db)
├── Node serialization           ├── Normalized storage
├── Graph relationships (edges)  ├── Fast queries
├── Human-readable format        ├── Indexing
├── Version control friendly     └── Audit trail

Sync: Sessions tracked in both, queries route to appropriate store
```

**2. Smart Attribution (SessionManager):**
```
Scoring Algorithm:
  score = (file_pattern_match × 0.4) +
          (keyword_match × 0.3) +
          (type_priority × 0.2) +
          (is_primary × 0.1)

Type Priorities: bug (1.0) > feature (0.8) > spike (0.6) > chore (0.4) > epic (0.2)

Usage: Auto-link activities to most relevant feature
```

**3. Drift Detection:**
```
Thresholds:
├── Time-based: 15 minutes without activity on primary feature
├── Event-based: 5+ consecutive activities on different features
└── Score-based: Attribution confidence < 0.7

Workflow:
1. Track activity
2. Calculate attribution score
3. If drift detected → warn agent
4. Queue for manual classification if high confidence
5. Auto-classify when threshold met
```

**4. Orchestrator Mode (Enforcement):**
```
Decision Points:
├── PreToolUse: Block tool if not delegable
├── PostToolUse: Reflect on whether delegation would help
└── SessionStart: Inject system prompt with delegation guidance

Modes:
├── Strict: Block all direct operations (delegate only)
├── Balanced: Allow direct ops, suggest delegation
├── Relaxed: Allow all, just track
└── Disabled: No enforcement
```

**5. Event Tracing (Correlation):**
```
Flow:
1. PreToolUse: Generate UUID (tool_use_id)
2. PreToolUse: Insert tool_traces START event
3. Tool executes...
4. PostToolUse: Find START event by tool_use_id
5. PostToolUse: Update with output, duration, status
6. Dashboard: Correlate via tool_use_id

Nested Traces: parent_tool_use_id for call hierarchy
```

**6. Query Builder Pattern:**
```
Example:
sdk.features.where(status='todo', priority='high')
            .limit(10)
            .order_by('created_at', desc=True)
            .select()

Compiles to: SQL WHERE clauses with indexes
```

---

### 7. PERFORMANCE CHARACTERISTICS

**Query Performance:**
- Session queries: O(1) via `idx_agent_events_session`
- Status filtering: O(log n) via `idx_features_status`
- Temporal queries: O(log n) via DESC timestamp indexes
- Cache hits: 30-second TTL covers 80% of repeated queries

**Memory Usage:**
- Graph nodes lazy-loaded (not all in memory)
- Session snapshots: read-only copy, safe for concurrency
- Query cache: Bounded by TTL (auto-eviction)
- Tool traces: Streaming via WebSocket (not all buffered)

**I/O Optimization:**
- Index-backed queries (no full table scans)
- Batch inserts via tool_traces
- Dashboard sync: Conditional cache invalidation
- Session file deduplication: 120-second window

**Scalability:**
- SQLite: Suitable for 1M+ events (with archiving)
- Sharding: Can archive old events to separate DB
- Connection pooling: Single persistent aiosqlite connection
- Async I/O: Non-blocking on FastAPI endpoints

---

### 8. DEPLOYMENT & PACKAGING

**Distribution:**
- PyPI: `htmlgraph` package with full SDK
- Claude Plugin: `packages/claude-plugin/` for auto-discovery
- Gemini Extension: `packages/gemini-extension/`
- MCP Server: Model Context Protocol integration

**Version Management:**
- Semantic versioning (MAJOR.MINOR.PATCH)
- Version in: `pyproject.toml`, `__init__.py`, `plugin.json`
- Release: `./scripts/deploy-all.sh VERSION --no-confirm`

**Database Initialization:**
- Auto-creates `.htmlgraph/htmlgraph.db` on first instantiation
- Schema version tracking (future-proof migrations)
- Backward compatibility via lazy migrations

---

### 9. CRITICAL INSIGHTS

**Strengths:**
1. **Unified Architecture**: HTML graphs + SQLite = best of both worlds
   - HTML: Human-readable, version-controllable, graph structure
   - SQLite: Fast queries, indexing, referential integrity

2. **Parallel Hook Execution**: 40-50% speedup via asyncio
   - PreToolUse: Orchestrator + Validator + Tracing simultaneously
   - PostToolUse: 6 tasks in parallel (tracking, reflection, validation, etc.)

3. **Smart Attribution**: Weighted scoring prevents manual tracking
   - Files, keywords, type priority automatically link to features
   - Drift detection flags off-track work before it accumulates

4. **Event Correlation**: tool_use_id links PreToolUse ↔ PostToolUse
   - Creates audit trail for debugging
   - Enables accurate cost accounting

5. **Graceful Degradation**: Hooks fail safely
   - Tool execution continues even if tracking fails
   - Dashboard still functional if cache misses

**Potential Improvements:**
1. **Sharding Strategy**: Archive old events to separate DB
2. **Incremental Sync**: Only sync modified HTML → SQLite
3. **Query Optimization**: Add composite indexes for common joins
4. **Caching**: Redis support for multi-instance deployments
5. **Metrics**: Prometheus-compatible instrumentation

**Design Philosophy:**
- Zero dependencies (HTML, CSS, JS, SQLite)
- Offline-first (works without internet)
- Human-observable (all data readable in HTML)
- AI-friendly (fluent APIs, batch operations, context-aware)
            </div>
        </section>
    </article>
</body>
</html>
